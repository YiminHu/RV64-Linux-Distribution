diff --git a/glibc-2.14.1/configure b/glibc-2.14.1/configure
index 6cf85e5..c2571b5 100755
--- a/glibc-2.14.1/configure
+++ glibc-2.14.1/configure
@@ -5002,7 +5002,7 @@ $as_echo_n "checking version of $MAKE... " >&6; }
   ac_prog_version=`$MAKE --version 2>&1 | sed -n 's/^.*GNU Make[^0-9]*\([0-9][0-9.]*\).*$/\1/p'`
   case $ac_prog_version in
     '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
-    3.79* | 3.[89]*)
+    3.79* | 3.[89]* | [4-9].* | [1-9][0-9]*)
        ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
     *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
 
diff --git a/glibc-2.14.1/configure.in b/glibc-2.14.1/configure.in
index fbc64b9..caf7c09 100644
--- a/glibc-2.14.1/configure.in
+++ glibc-2.14.1/configure.in
@@ -1030,7 +1030,7 @@ AC_CHECK_PROG_VER(CC, ${ac_tool_prefix}gcc ${ac_tool_prefix}cc, -v,
   critic_missing="$critic_missing gcc")
 AC_CHECK_PROG_VER(MAKE, gnumake gmake make, --version,
   [GNU Make[^0-9]*\([0-9][0-9.]*\)],
-  [3.79* | 3.[89]*], critic_missing="$critic_missing make")
+  [3.79* | 3.[89]* | [4-9].* | [1-9][0-9]*], critic_missing="$critic_missing make")
 
 AC_CHECK_PROG_VER(MSGFMT, gnumsgfmt gmsgfmt msgfmt, --version,
   [GNU gettext.* \([0-9]*\.[0-9.]*\)],
diff --git a/glibc-2.14.1/scripts/config.sub b/glibc-2.14.1/scripts/config.sub
index 459eb41..46a0794 100755
--- a/glibc-2.14.1/scripts/config.sub
+++ glibc-2.14.1/scripts/config.sub
@@ -290,6 +290,7 @@ case $basic_machine in
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
+	| riscv \
 	| rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
diff --git a/glibc-2.14.1/shlib-versions b/glibc-2.14.1/shlib-versions
index d3e8407..68754a1 100644
--- a/glibc-2.14.1/shlib-versions
+++ glibc-2.14.1/shlib-versions
@@ -31,6 +31,7 @@ cris-.*-linux.*		DEFAULT			GLIBC_2.2
 x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
 powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
 .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
+riscv-.*-linux.*	DEFAULT			GLIBC_2.14
 
 # Configuration		WORDSIZE[32|64]		Alternate configuration
 # -------------		----------		-----------------------
diff --git a/glibc-2.14.1/sysdeps/riscv/Implies b/glibc-2.14.1/sysdeps/riscv/Implies
new file mode 100644
index 0000000..3c3d8e7
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/Implies
@@ -0,0 +1,5 @@
+ieee754/flt-32
+ieee754/dbl-64
+
+# This needs to change to support rv32
+riscv/rv64
diff --git a/glibc-2.14.1/sysdeps/riscv/Makefile b/glibc-2.14.1/sysdeps/riscv/Makefile
new file mode 100644
index 0000000..cd9598a
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/Makefile
@@ -0,0 +1,49 @@
+ifneq ($(all-rtld-routines),)
+CFLAGS-rtld.c += -mno-plt
+CFLAGS-dl-load.c += -mno-plt
+CFLAGS-dl-cache.c += -mno-plt
+CFLAGS-dl-lookup.c += -mno-plt
+CFLAGS-dl-object.c += -mno-plt
+CFLAGS-dl-reloc.c += -mno-plt
+CFLAGS-dl-deps.c += -mno-plt
+CFLAGS-dl-runtime.c += -mno-plt
+CFLAGS-dl-error.c += -mno-plt
+CFLAGS-dl-init.c += -mno-plt
+CFLAGS-dl-fini.c += -mno-plt
+CFLAGS-dl-debug.c += -mno-plt
+CFLAGS-dl-misc.c += -mno-plt
+CFLAGS-dl-version.c += -mno-plt
+CFLAGS-dl-profile.c += -mno-plt
+CFLAGS-dl-conflict.c += -mno-plt
+CFLAGS-dl-tls.c += -mno-plt
+CFLAGS-dl-origin.c += -mno-plt
+CFLAGS-dl-scope.c += -mno-plt
+CFLAGS-dl-execstack.c += -mno-plt
+CFLAGS-dl-caller.c += -mno-plt
+CFLAGS-dl-open.c += -mno-plt
+CFLAGS-dl-close.c += -mno-plt
+CFLAGS-dl-sysdep.c += -mno-plt
+CFLAGS-dl-environ.c += -mno-plt
+CFLAGS-dl-minimal.c += -mno-plt
+CFLAGS-dl-static.c += -mno-plt
+CFLAGS-dl-brk.c += -mno-plt
+CFLAGS-dl-sbrk.c += -mno-plt
+CFLAGS-dl-getcwd.c += -mno-plt
+CFLAGS-dl-openat64.c += -mno-plt
+CFLAGS-dl-opendir.c += -mno-plt
+CFLAGS-dl-fxstatat64.c += -mno-plt
+endif
+
+CFLAGS-closedir.c += -mno-plt
+CFLAGS-exit.c += -mno-plt
+CFLAGS-cxa_atexit.c += -mno-plt
+
+ifeq ($(subdir),misc)
+sysdep_headers += sys/asm.h sgidefs.h
+endif
+
+ifeq ($(subdir),rt)
+librt-sysdep_routines += rt-sysdep
+endif
+
+ASFLAGS-.os += $(pic-ccflag)
diff --git a/glibc-2.14.1/sysdeps/riscv/Versions b/glibc-2.14.1/sysdeps/riscv/Versions
new file mode 100644
index 0000000..5a0c2d2
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.14 {
+    __memcpy_g;
+  }
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/__longjmp.S b/glibc-2.14.1/sysdeps/riscv/__longjmp.S
new file mode 100644
index 0000000..88f720e
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/__longjmp.S
@@ -0,0 +1,67 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+	REG_L ra,  0*SZREG(a0)
+	REG_L s0,  1*SZREG(a0)
+	REG_L s1,  2*SZREG(a0)
+	REG_L s2,  3*SZREG(a0)
+	REG_L s3,  4*SZREG(a0)
+	REG_L s4,  5*SZREG(a0)
+	REG_L s5,  6*SZREG(a0)
+	REG_L s6,  7*SZREG(a0)
+	REG_L s7,  8*SZREG(a0)
+	REG_L s8,  9*SZREG(a0)
+	REG_L s9, 10*SZREG(a0)
+	REG_L s10,11*SZREG(a0)
+	REG_L s11,12*SZREG(a0)
+	REG_L sp, 13*SZREG(a0)
+	REG_L tp, 14*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	REG_L a3, 15*SZREG(a0)
+
+	fld  fs0, 16*SZREG+ 0*8(a0)
+	fld  fs1, 16*SZREG+ 1*8(a0)
+	fld  fs2, 16*SZREG+ 2*8(a0)
+	fld  fs3, 16*SZREG+ 3*8(a0)
+	fld  fs4, 16*SZREG+ 4*8(a0)
+	fld  fs5, 16*SZREG+ 5*8(a0)
+	fld  fs6, 16*SZREG+ 6*8(a0)
+	fld  fs7, 16*SZREG+ 7*8(a0)
+	fld  fs8, 16*SZREG+ 8*8(a0)
+	fld  fs9, 16*SZREG+ 9*8(a0)
+	fld  fs10,16*SZREG+10*8(a0)
+	fld  fs11,16*SZREG+11*8(a0)
+	fld  fs12,16*SZREG+12*8(a0)
+	fld  fs13,16*SZREG+13*8(a0)
+	fld  fs14,16*SZREG+14*8(a0)
+	fld  fs15,16*SZREG+15*8(a0)
+
+	fssr a3
+#endif
+
+	sltu a3, a1, 1    # a3 = (a1 == 0)
+	add  v0, a3, a1   # v0 = (a1 == 0 ? 1 : a1)
+	ret
+
+END(__longjmp)
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/atomic.h b/glibc-2.14.1/sysdeps/riscv/bits/atomic.h
new file mode 100644
index 0000000..aaa62d7
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/atomic.h
@@ -0,0 +1,151 @@
+/* Low-level functions for atomic operations. Mips version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_BITS_ATOMIC_H
+#define _MIPS_BITS_ATOMIC_H 1
+
+#include <inttypes.h>
+#include <sgidefs.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#ifdef __riscv_atomic
+
+#define asm_amo(which, ordering, mem, value) ({ 		\
+  typeof(*mem) __tmp; 						\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile (which ".w" ordering "\t%0, %z1, (%2)" : "=r"(__tmp) : "rJ"(value), "r"(mem)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile (which ".d" ordering "\t%0, %z1, (%2)" : "=r"(__tmp) : "rJ"(value), "r"(mem)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define asm_load_reserved(ordering, mem) ({ 			\
+  typeof(*mem) __tmp; 						\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile ("lr.w" ordering "\t%0, (%1)" : "=r"(__tmp) : "r"(mem)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile ("lr.d" ordering "\t%0, (%1)" : "=r"(__tmp) : "r"(mem)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define asm_store_conditional(ordering, mem, value) \
+  asm_amo("sc", ordering, mem, value)
+
+/* Atomic compare and exchange. */
+
+#define atomic_cas(ordering, mem, newval, oldval) ({ 	\
+  typeof(*mem) __tmp; 						\
+  int __tmp2; 							\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile ("1: lr.w" ordering "\t%0, (%2)\n"		\
+                  "bne\t%0, %z4, 1f\n"				\
+		  "sc.w" ordering "\t%1, %z3, (%2)\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2) : "r"(mem), "rJ"(newval), "rJ"(oldval)); \
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile ("1: lr.d" ordering "\t%0, (%2)\n"		\
+                  "bne\t%0, %z4, 1f\n"				\
+		  "sc.d" ordering "\t%1, %z3, (%2)\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2) : "r"(mem), "rJ"(newval), "rJ"(oldval)); \
+  else								\
+    abort();							\
+  __tmp; })
+
+#define atomic_cas_bool(ordering, mem, newval, oldval) ({ 	\
+  __label__ failure, success;					\
+  typeof(*mem) __tmp; 						\
+  int __res;							\
+  if (sizeof(__tmp) == 4)					\
+    asm goto ("1: lr.w" ordering "\tt3, (%0)\n"			\
+                  "bne\tt3, %z2, %l[failure]\n"			\
+		  "sc.w" ordering "\tt3, %z1, (%0)\n"		\
+		  "bnez\tt3, 1b"				\
+		  : : "r"(mem), "rJ"(newval), "rJ"(oldval) : "t3" : failure); \
+  else if (sizeof(__tmp) == 8)					\
+    asm goto ("1: lr.d" ordering "\tt3, (%0)\n"			\
+                  "bne\tt3, %z2, %l[failure]\n"			\
+		  "sc.d" ordering "\tt3, %z1, (%0)\n"		\
+		  "bnez\tt3, 1b"				\
+		  : : "r"(mem), "rJ"(newval), "rJ"(oldval) : "t3" : failure); \
+  else								\
+    abort();							\
+  __res = 0;							\
+  goto success;							\
+failure:							\
+  __res = 1;							\
+success:							\
+  __res; })
+
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  atomic_cas(".aq", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_val_rel(mem, newval, oldval) \
+  atomic_cas(".rl", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  atomic_cas_bool(".aq", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_bool_rel(mem, newval, oldval) \
+  atomic_cas_bool(".rl", mem, newval, oldval)
+
+/* Atomic exchange (without compare).  */
+
+#define atomic_exchange_acq(mem, value) asm_amo("amoswap", ".aq", mem, value)
+#define atomic_exchange_rel(mem, value) asm_amo("amoswap", ".rl", mem, value)
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+#define atomic_exchange_and_add(mem, value) asm_amo("amoadd", "", mem, value)
+
+#define atomic_max(mem, value) asm_amo("amomaxu", "", mem, value)
+#define atomic_min(mem, value) asm_amo("amominu", "", mem, value)
+
+#define atomic_bit_test_set(mem, bit)                   \
+  ({ typeof(*mem) __mask = (typeof(*mem))1 << (bit);    \
+     asm_amo("amoor", "", mem, __mask) & __mask; })
+
+#define atomic_full_barrier() __sync_synchronize()
+
+#define catomic_exchange_and_add(mem, value)		\
+  atomic_exchange_and_add(mem, value)
+#define catomic_max(mem, value) atomic_max(mem, value)
+
+#endif /* __riscv_atomic */
+
+#endif /* bits/atomic.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/dlfcn.h b/glibc-2.14.1/sysdeps/riscv/bits/dlfcn.h
new file mode 100644
index 0000000..a5b5bf5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/dlfcn.h
@@ -0,0 +1,66 @@
+/* System dependent definitions for run-time dynamic loading.
+   Copyright (C) 1996, 1997, 1999, 2000, 2001, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DLFCN_H
+# error "Never use <bits/dlfcn.h> directly; include <dlfcn.h> instead."
+#endif
+
+/* The MODE argument to `dlopen' contains one of the following: */
+#define RTLD_LAZY	0x0001	/* Lazy function call binding.  */
+#define RTLD_NOW	0x0002	/* Immediate function call binding.  */
+#define RTLD_BINDING_MASK  0x3	/* Mask of binding time value.  */
+#define RTLD_NOLOAD	0x00008	/* Do not load the object.  */
+#define RTLD_DEEPBIND	0x00010	/* Use deep binding.  */
+
+/* If the following bit is set in the MODE argument to `dlopen',
+   the symbols of the loaded object and its dependencies are made
+   visible as if the object were linked directly into the program.  */
+#define RTLD_GLOBAL	0x0004
+
+/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
+   The implementation does this by default and so we can define the
+   value to zero.  */
+#define RTLD_LOCAL      0
+
+/* Do not delete object when closed.  */
+#define RTLD_NODELETE	0x01000
+
+#ifdef __USE_GNU
+/* To support profiling of shared objects it is a good idea to call
+   the function found using `dlsym' using the following macro since
+   these calls do not use the PLT.  But this would mean the dynamic
+   loader has no chance to find out when the function is called.  The
+   macro applies the necessary magic so that profiling is possible.
+   Rewrite
+	foo = (*fctp) (arg1, arg2);
+   into
+        foo = DL_CALL_FCT (fctp, (arg1, arg2));
+*/
+# define DL_CALL_FCT(fctp, args) \
+  (_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)
+
+__BEGIN_DECLS
+
+/* This function calls the profiling functions.  */
+extern void _dl_mcount_wrapper_check (void *__selfpc) __THROW;
+
+__END_DECLS
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/endian.h b/glibc-2.14.1/sysdeps/riscv/bits/endian.h
new file mode 100644
index 0000000..4aaf559
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/endian.h
@@ -0,0 +1,5 @@
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/fenv.h b/glibc-2.14.1/sysdeps/riscv/bits/fenv.h
new file mode 100644
index 0000000..0ccf5cb
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/fenv.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+enum
+  {
+    FE_INEXACT = 0x01,
+#define FE_INEXACT	FE_INEXACT
+    FE_UNDERFLOW = 0x02,
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 0x04,
+#define FE_OVERFLOW	FE_OVERFLOW
+    FE_DIVBYZERO = 0x08,
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_INVALID = 0x10,
+#define FE_INVALID	FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0x0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 0x1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_DOWNWARD = 0x2,
+#define FE_DOWNWARD	FE_DOWNWARD
+    FE_UPWARD = 0x3
+#define FE_UPWARD	FE_UPWARD
+  };
+
+
+typedef unsigned int fexcept_t;
+typedef unsigned int fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/ipctypes.h b/glibc-2.14.1/sysdeps/riscv/bits/ipctypes.h
new file mode 100644
index 0000000..0956e7d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/ipctypes.h
@@ -0,0 +1,32 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.  MIPS version
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include <bits/ipctypes.h> directly.
+ */
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+typedef __SLONG32_TYPE __ipc_pid_t;
+
+
+#endif /* bits/ipctypes.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/link.h b/glibc-2.14.1/sysdeps/riscv/bits/link.h
new file mode 100644
index 0000000..f216ebd
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/link.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_mips_64_regs
+{
+  unsigned long lr_reg[8]; /* $a0 through $a7 */
+  double lr_fpreg[8]; /* $f4 throgh $f11 */
+  unsigned long lr_ra;
+  unsigned long lr_sp;
+} La_mips_64_regs;
+
+/* Return values for calls from PLT on MIPS.  */
+typedef struct La_mips_64_retval
+{
+  unsigned long lrv_v0;
+  unsigned long lrv_v1;
+  double lrv_fv0;
+  double lrv_fv1;
+} La_mips_64_retval;
+
+__BEGIN_DECLS
+
+#if _RISCV_SIM == _ABI32
+
+extern Elf32_Addr la_mips_n32_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n32_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#else
+
+extern Elf64_Addr la_mips_n64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#endif
+
+__END_DECLS
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/linkmap.h b/glibc-2.14.1/sysdeps/riscv/bits/linkmap.h
new file mode 100644
index 0000000..a6df782
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/linkmap.h
@@ -0,0 +1,4 @@
+struct link_map_machine
+  {
+    ElfW(Addr) plt; /* Address of .plt */
+  };
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/mathdef.h b/glibc-2.14.1/sysdeps/riscv/bits/mathdef.h
new file mode 100644
index 0000000..1fef80f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/mathdef.h
@@ -0,0 +1,45 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2007
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#include <sgidefs.h>
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* MIPS has `float' and `double' operations.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	2147483647
+
+#endif	/* ISO C99 */
+
+#if ! defined __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/nan.h b/glibc-2.14.1/sysdeps/riscv/bits/nan.h
new file mode 100644
index 0000000..baaaa55
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/nan.h
@@ -0,0 +1,56 @@
+/* `NAN' constant for IEEE 754 machines.
+   Copyright (C) 1992, 1996, 1997, 1999, 2002, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/nan.h> directly; include <math.h> instead."
+#endif
+
+
+/* IEEE Not A Number (QNaN). Note that MIPS has the QNaN and SNaN patterns
+   reversed compared to most other architectures. The IEEE spec left
+   the definition of this open to implementations, and for MIPS the top
+   bit of the mantissa must be SET to indicate a SNaN.  */
+
+#if __GNUC_PREREQ(3,3)
+
+# define NAN	(__builtin_nanf(""))
+
+#elif defined __GNUC__
+
+# define NAN \
+  (__extension__                                                            \
+   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })  \
+    { __l: 0x7fbfffffUL }).__d)
+
+#else
+
+# include <endian.h>
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __nan_bytes		{ 0x7f, 0xbf, 0xff, 0xff }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __nan_bytes		{ 0xff, 0xff, 0xbf, 0x7f }
+# endif
+
+static union { unsigned char __c[4]; float __d; } __nan_union = { __nan_bytes };
+# define NAN	(__nan_union.__d)
+
+#endif	/* GCC.  */
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/setjmp.h b/glibc-2.14.1/sysdeps/riscv/bits/setjmp.h
new file mode 100644
index 0000000..52e2d3d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/setjmp.h
@@ -0,0 +1,43 @@
+/* Define the machine-dependent type `jmp_buf'.  RISC-V version.
+   Copyright (C) 1992,1993,1995,1997,2000,2002,2003,2004,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_BITS_SETJMP_H
+#define _RISCV_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+  {
+    /* Program counter.  */
+    long __pc;
+    /* Callee-saved registers. */
+    long __regs[12];
+    /* Stack pointer.  */
+    long __sp;
+    /* Thread pointer. */
+    long __tp;
+    /* Floating point status register.  */
+    long __fsr;
+
+    /* Callee-saved floating point registers.
+       Note that there are an even number of preceding words in this struct,
+       so no padding will be inserted before __fpregs, even for RV32. */
+    double __fpregs[16];
+  } __jmp_buf[1];
+
+#endif /* _RISCV_BITS_SETJMP_H */
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/string.h b/glibc-2.14.1/sysdeps/riscv/bits/string.h
new file mode 100644
index 0000000..5f9dca5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/string.h
@@ -0,0 +1,55 @@
+/* This file should provide inline versions of string functions.
+
+   Surround GCC-specific parts with #ifdef __GNUC__, and use `__extern_inline'.
+
+   This file should define __STRING_INLINES if functions are actually defined
+   as inlines.  */
+
+#ifndef _BITS_STRING_H
+#define _BITS_STRING_H	1
+
+#if defined(__GNUC__) && !defined(__cplusplus)
+
+static inline unsigned long __libc_detect_null(unsigned long w)
+{
+  unsigned long mask = 0x7f7f7f7f;
+  if (sizeof(long) == 8)
+    mask = ((mask << 16) << 16) | mask;
+  return ~(((w & mask) + mask) | w | mask);
+}
+
+#define _HAVE_STRING_ARCH_memcpy 1
+#define __use_memcpy_align(k, d, s, n) \
+  (__builtin_constant_p(n) && (n) % (k) == 0 && (n) <= 64 && \
+   __alignof__(*(d)) >= (k) && __alignof__(*(s)) >= (k))
+#define memcpy(d, s, n) \
+  (__use_memcpy_align(8, d, s, n) ? __memcpy_align8(d, s, n) : \
+   __use_memcpy_align(4, d, s, n) ? __memcpy_align4(d, s, n) : \
+   __memcpy_g(d, s, n))
+
+#define __declare_memcpy_align(size, type) \
+  static inline void *__memcpy_align ## size(void *__restrict __dest, \
+                        __const void *__restrict __src, size_t __n) { \
+    type *__d = (type*)__dest; \
+    const type *__s = (const type*)__src, *__e = (const type*)(__src + __n); \
+    while (__s < __e) { \
+      type __t = *__s; \
+      __d++, __s++; \
+      *(__d-1) = __t; \
+    } \
+    return __dest; \
+  }
+__declare_memcpy_align(8, long long)
+__declare_memcpy_align(4, int)
+
+#ifdef _LIBC
+extern void *__memcpy_g (void *__restrict __dest,
+                         __const void *__restrict __src, size_t __n);
+libc_hidden_proto (__memcpy_g)
+#else
+# define __memcpy_g memcpy
+#endif
+
+#endif /* __GNUC__ && !__cplusplus */
+
+#endif /* bits/string.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/bits/wordsize.h b/glibc-2.14.1/sysdeps/riscv/bits/wordsize.h
new file mode 100644
index 0000000..f956c87
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bits/wordsize.h
@@ -0,0 +1,22 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	_RISCV_SZPTR
+#if _RISCV_SIM == _ABI64
+# define __WORDSIZE_COMPAT32	1
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/bsd-_setjmp.c b/glibc-2.14.1/sysdeps/riscv/bsd-_setjmp.c
new file mode 100644
index 0000000..0d41310
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bsd-_setjmp.c
@@ -0,0 +1 @@
+/* _setjmp is implemented in setjmp.S */
diff --git a/glibc-2.14.1/sysdeps/riscv/bsd-setjmp.c b/glibc-2.14.1/sysdeps/riscv/bsd-setjmp.c
new file mode 100644
index 0000000..ee7c5e3
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/bsd-setjmp.c
@@ -0,0 +1 @@
+/* setjmp is implemented in setjmp.S */
diff --git a/glibc-2.14.1/sysdeps/riscv/dl-dtprocnum.h b/glibc-2.14.1/sysdeps/riscv/dl-dtprocnum.h
new file mode 100644
index 0000000..adf8dfa
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/dl-dtprocnum.h
@@ -0,0 +1,33 @@
+/* Configuration of lookup functions.  MIPS version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Number of local global offset table entries.  */
+#define DT_RISCV_LOCAL_GOTNO	0x70000000
+
+/* Number of entries in the .dynsym section.  */
+#define DT_RISCV_SYMTABNO	0x70000001
+
+/* Index of first dynamic symbol in global offset table.  */
+#define DT_RISCV_GOTSYM		0x70000002
+
+/* Address of the base of the PLTGOT.  */
+#define DT_RISCV_PLTGOT         0x70000003
+
+/* Number of extra dynamic section entries for this architecture. */
+#define DT_THISPROCNUM	4
diff --git a/glibc-2.14.1/sysdeps/riscv/dl-machine.h b/glibc-2.14.1/sysdeps/riscv/dl-machine.h
new file mode 100644
index 0000000..414af3f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/dl-machine.h
@@ -0,0 +1,559 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "RISC-V"
+
+/* Relocs. */
+#define R_RISCV_COPY         24
+#define R_RISCV_JUMP_SLOT    25
+#define R_RISCV_TLS_DTPMOD32 38
+#define R_RISCV_TLS_DTPREL32 39
+#define R_RISCV_TLS_DTPMOD64 40
+#define R_RISCV_TLS_DTPREL64 41
+#define R_RISCV_TLS_TPREL32  47
+#define R_RISCV_TLS_TPREL64  48
+
+#include <entry.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for MIPS.
+#endif
+
+#include <sys/asm.h>
+#include <dl-tls.h>
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING(entry) "\n\t"				\
+	".type\t" __STRING(entry) ", @function\n"			\
+	__STRING(entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".size\t" __STRING(entry) ", . - " __STRING(entry) "\n\t"
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.
+   This only makes sense on MIPS when using PLTs, so choose the
+   PLT relocation (not encountered when not using PLTs).  */
+#define ELF_MACHINE_JMP_SLOT			R_RISCV_JUMP_SLOT
+#define elf_machine_type_class(type)				\
+  ((ELF_RTYPE_CLASS_PLT * ((type) == ELF_MACHINE_JMP_SLOT	\
+     || _RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPREL32	\
+     || _RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPMOD32	\
+     || _RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_TPREL32	\
+     || _RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPREL64	\
+     || _RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPMOD64	\
+     || _RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_TPREL64))	\
+   | (ELF_RTYPE_CLASS_COPY * ((type) == R_RISCV_COPY)))
+
+#define ELF_MACHINE_NO_RELA 1
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_RISCV(x) (DT_RISCV_##x - DT_LOPROC + DT_NUM)
+
+#define ELF_MACHINE_DEBUG_SETUP(l,r)
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  return 1;
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  extern ElfW(Addr) _GLOBAL_OFFSET_TABLE_ __attribute__ ((visibility("hidden")));
+  return _GLOBAL_OFFSET_TABLE_;
+}
+
+#define STRINGXP(X) __STRING(X)
+#define STRINGXV(X) STRINGV_(X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  /* Subtract the link-time address of _DYNAMIC from its runtime address. */
+  extern ElfW(Dyn) _DYNAMIC[] __attribute__ ((visibility("hidden")));
+  return (char*)&_DYNAMIC - elf_machine_dynamic ();
+}
+
+/* We can't rely on elf_machine_got_rel because _dl_object_relocation_scope
+   fiddles with global data.  */
+#define ELF_MACHINE_BEFORE_RTLD_RELOC(dynamic_info)			\
+do {									\
+  struct link_map *map = &bootstrap_map;				\
+  ElfW(Sym) *sym;							\
+  ElfW(Addr) *got;							\
+  int i, n;								\
+									\
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);			\
+									\
+  if (__builtin_expect (map->l_addr == 0, 1))				\
+    break;								\
+									\
+  i = 2; /* got[0] and got[1] are reserved. */				\
+  n = map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val;			\
+									\
+  /* Add the run-time displacement to all local got entries. */		\
+  while (i < n)								\
+    got[i++] += map->l_addr;						\
+									\
+  /* Handle global got entries. */					\
+  got += n;								\
+  sym = (ElfW(Sym) *) D_PTR(map, l_info[DT_SYMTAB])			\
+       + map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;			\
+  i = (map->l_info[DT_RISCV (SYMTABNO)]->d_un.d_val			\
+       - map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val);			\
+									\
+  while (i--)								\
+    {									\
+      if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)	\
+	*got = map->l_addr + sym->st_value;				\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC			\
+	       && *got != sym->st_value)				\
+	*got += map->l_addr;						\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)		\
+	{								\
+	  if (sym->st_other == 0)					\
+	    *got += map->l_addr;					\
+	}								\
+      else								\
+	*got = map->l_addr + sym->st_value;				\
+									\
+      got++;								\
+      sym++;								\
+    }									\
+} while(0)
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point. */
+
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	# Store &_DYNAMIC in the first entry of the GOT.\n\
+	la a0, _DYNAMIC\n\
+	" STRINGXP(REG_S) " a0, _GLOBAL_OFFSET_TABLE_, a1\n\
+	move a0, sp\n\
+	jal _dl_start\n\
+	# Stash user entry point in s0.\n\
+	move s0, v0\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw v0, _dl_skip_args\n\
+	# Load the original argument count.\n\
+	" STRINGXP(REG_L) " a1, 0(sp)\n\
+	# Subtract _dl_skip_args from it.\n\
+	sub a1, a1, v0\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll v0, v0, " STRINGXP (PTRLOG) "\n\
+	add sp, sp, v0\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(REG_S) " a1, 0(sp)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(REG_L) " a0, _rtld_local\n\
+	add a2, sp, " STRINGXP (SZREG) "\n\
+	sll a3, a1, " STRINGXP (PTRLOG) "\n\
+	add a3, a3, a2\n\
+	add a3, a3, " STRINGXP (SZREG) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init_internal\n\
+	# Pass our finalizer function to the user in v0 as per ELF ABI.\n\
+	lla v0, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	jr s0\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	.previous" \
+);
+
+/* Names of the architecture-specific auditing callback functions.  */
+# ifdef __riscv64
+#  define ARCH_LA_PLTENTER mips_n64_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n64_gnu_pltexit
+# else
+#  define ARCH_LA_PLTENTER mips_n32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n32_gnu_pltexit
+# endif
+
+/* Bias .got.plt entry by the offset requested by the PLT header. */
+#define elf_machine_plt_value(map, reloc, value) (value)
+#define elf_machine_fixup_plt(map, t, reloc, reloc_addr, value) \
+  (*(ElfW(Addr) *)(reloc_addr) = (value))
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,
+		 const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr)
+{
+  ElfW(Addr) r_info = reloc->r_info;
+  const unsigned long int r_type = ELFW(R_TYPE) (r_info);
+  ElfW(Addr) *addr_field = (ElfW(Addr) *) reloc_addr;
+
+#if !defined RTLD_BOOTSTRAP && !defined SHARED
+  /* This is defined in rtld.c, but nowhere in the static libc.a;
+     make the reference weak so static programs can still link.  This
+     declaration cannot be done when compiling rtld.c (i.e.  #ifdef
+     RTLD_BOOTSTRAP) because rtld.c contains the common defn for
+     _dl_rtld_map, which is incompatible with a weak decl in the same
+     file.  */
+  weak_extern (GL(dl_rtld_map));
+#endif
+
+  switch (r_type)
+    {
+#if defined (USE_TLS) && !defined (RTLD_BOOTSTRAP)
+# if _RISCV_SIM == _ABI64
+    case R_MIPS_TLS_DTPMOD64:
+    case R_MIPS_TLS_DTPREL64:
+    case R_MIPS_TLS_TPREL64:
+# else
+    case R_MIPS_TLS_DTPMOD32:
+    case R_MIPS_TLS_DTPREL32:
+    case R_MIPS_TLS_TPREL32:
+# endif
+      {
+	struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+
+	switch (r_type)
+	  {
+	  case R_MIPS_TLS_DTPMOD64:
+	  case R_MIPS_TLS_DTPMOD32:
+	    if (sym_map)
+	      *addr_field = sym_map->l_tls_modid;
+	    break;
+
+	  case R_MIPS_TLS_DTPREL64:
+	  case R_MIPS_TLS_DTPREL32:
+	    if (sym)
+	      *addr_field += TLS_DTPREL_VALUE (sym);
+	    break;
+
+	  case R_MIPS_TLS_TPREL32:
+	  case R_MIPS_TLS_TPREL64:
+	    if (sym)
+	      {
+		CHECK_STATIC_TLS (map, sym_map);
+		*addr_field += TLS_TPREL_VALUE (sym_map, sym);
+	      }
+	    break;
+	  }
+
+	break;
+      }
+#endif
+
+    case R_MIPS_REL32:
+      {
+	int symidx = ELFW(R_SYM) (r_info);
+
+	if (symidx)
+	  {
+	    const ElfW(Word) gotsym
+	      = (const ElfW(Word)) map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;
+
+	    if ((ElfW(Word))symidx < gotsym)
+	      {
+		/* This wouldn't work for a symbol imported from other
+		   libraries for which there's no GOT entry, but MIPS
+		   requires every symbol referenced in a dynamic
+		   relocation to have a GOT entry in the primary GOT,
+		   so we only get here for locally-defined symbols.
+		   For section symbols, we should *NOT* be adding
+		   sym->st_value (per the definition of the meaning of
+		   S in reloc expressions in the ELF64 MIPS ABI),
+		   since it should have already been added to
+		   reloc_value by the linker, but older versions of
+		   GNU ld didn't add it, and newer versions don't emit
+		   useless relocations to section symbols any more, so
+		   it is safe to keep on adding sym->st_value, even
+		   though it's not ABI compliant.  Some day we should
+		   bite the bullet and stop doing this.  */
+#ifndef RTLD_BOOTSTRAP
+		if (map != &GL(dl_rtld_map))
+#endif
+		  if (sym->st_value + map->l_addr)
+		    *addr_field += sym->st_value + map->l_addr;
+	      }
+	    else
+	      {
+#ifndef RTLD_BOOTSTRAP
+		const ElfW(Addr) *got
+		  = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+		const ElfW(Word) local_gotno
+		  = (const ElfW(Word))
+		    map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val;
+
+		*addr_field += got[symidx + local_gotno - gotsym];
+#endif
+	      }
+	  }
+	else
+#ifndef RTLD_BOOTSTRAP
+	  if (map != &GL(dl_rtld_map))
+#endif
+	    if (map->l_addr)
+	      *addr_field += map->l_addr;
+      }
+      break;
+#ifndef RTLD_BOOTSTRAP
+    case R_MIPS_GLOB_DAT:
+      {
+	int symidx = ELFW(R_SYM) (r_info);
+	const ElfW(Word) gotsym
+	  = (const ElfW(Word)) map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;
+
+	if (__builtin_expect ((ElfW(Word)) symidx >= gotsym, 1))
+	  {
+	    const ElfW(Addr) *got
+	      = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+	    const ElfW(Word) local_gotno
+	      = ((const ElfW(Word))
+		 map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val);
+
+	    ElfW(Addr) reloc_value = got[symidx + local_gotno - gotsym];
+	    __builtin_memcpy (reloc_addr, &reloc_value, sizeof (reloc_value));
+	  }
+      }
+      break;
+#endif
+    case R_MIPS_NONE:		/* Alright, Wilbur.  */
+      break;
+
+    case R_RISCV_JUMP_SLOT:
+      {
+	struct link_map *sym_map;
+	ElfW(Addr) value;
+
+	sym_map = RESOLVE_MAP (&sym, version, r_type);
+	value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+	*addr_field = value;
+
+	break;
+      }
+
+    case R_RISCV_COPY:
+      {
+	const ElfW(Sym) *const refsym = sym;
+	struct link_map *sym_map;
+	ElfW(Addr) value;
+
+	/* Calculate the address of the symbol.  */
+	sym_map = RESOLVE_MAP (&sym, version, r_type);
+	value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+	if (__builtin_expect (sym == NULL, 0))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+	if (__builtin_expect (sym->st_size > refsym->st_size, 0)
+	    || (__builtin_expect (sym->st_size < refsym->st_size, 0)
+		&& GLRO(dl_verbose)))
+	  {
+	    const char *strtab;
+
+	    strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+			      rtld_progname ?: "<program name unknown>",
+			      strtab + refsym->st_name);
+	  }
+	memcpy (reloc_addr, (void *) value,
+	        MIN (sym->st_size, refsym->st_size));
+	break;
+      }
+
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,
+			  void *const reloc_addr)
+{
+  /* XXX Nothing to do.  There is no relative relocation, right?  */
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_lazy_rel (struct link_map *map,
+		      ElfW(Addr) l_addr, const ElfW(Rel) *reloc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW(R_TYPE) (reloc->r_info);
+  /* Check for unexpected PLT reloc type.  */
+  if (__builtin_expect (r_type == R_RISCV_JUMP_SLOT, 1))
+    {
+      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+	{
+	  /* Nothing is required here since we only support lazy
+	     relocation in executables.  */
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+#ifndef RTLD_BOOTSTRAP
+/* Relocate GOT. */
+auto inline void
+__attribute__((always_inline))
+elf_machine_got_rel (struct link_map *map, int lazy)
+{
+  ElfW(Addr) *got;
+  ElfW(Sym) *sym;
+  const ElfW(Half) *vernum;
+  int i, n, symidx;
+
+#define RESOLVE_GOTSYM(sym,vernum,sym_index,reloc)			  \
+    ({									  \
+      const ElfW(Sym) *ref = sym;					  \
+      const struct r_found_version *version				  \
+        = vernum ? &map->l_versions[vernum[sym_index] & 0x7fff] : NULL;	  \
+      struct link_map *sym_map;						  \
+      sym_map = RESOLVE_MAP (&ref, version, reloc);			  \
+      ref ? sym_map->l_addr + ref->st_value : 0;			  \
+    })
+
+  if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+    vernum = (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
+  else
+    vernum = NULL;
+
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+
+  n = map->l_info[DT_RISCV (LOCAL_GOTNO)]->d_un.d_val;
+  /* The dynamic linker's local got entries have already been relocated.  */
+  if (map != &GL(dl_rtld_map))
+    {
+      /* got[0] and got[1] are reserved. */
+      i = 2;
+
+      /* Add the run-time displacement to all local got entries if
+         needed.  */
+      if (__builtin_expect (map->l_addr != 0, 0))
+	{
+	  while (i < n)
+	    got[i++] += map->l_addr;
+	}
+    }
+
+  /* Handle global got entries. */
+  got += n;
+  /* Keep track of the symbol index.  */
+  symidx = map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val;
+  sym = (ElfW(Sym) *) D_PTR (map, l_info[DT_SYMTAB]) + symidx;
+  i = (map->l_info[DT_RISCV (SYMTABNO)]->d_un.d_val
+       - map->l_info[DT_RISCV (GOTSYM)]->d_un.d_val);
+
+  /* This loop doesn't handle Quickstart.  */
+  while (i--)
+    {
+      if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC
+	       && *got != sym->st_value)
+	{
+	  if (lazy)
+	    *got += map->l_addr;
+	  else
+	    /* This is a lazy-binding stub, so we don't need the
+	       canonical address.  */
+	    *got = RESOLVE_GOTSYM (sym, vernum, symidx, R_RISCV_JUMP_SLOT);
+	}
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)
+	{
+	  if (sym->st_other == 0)
+	    *got += map->l_addr;
+	}
+      else
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+
+      ++got;
+      ++sym;
+      ++symidx;
+    }
+
+#undef RESOLVE_GOTSYM
+}
+#endif
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+auto inline int
+__attribute__((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+# ifndef RTLD_BOOTSTRAP
+  /* Relocate global offset table.  */
+  elf_machine_got_rel (l, lazy);
+
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL])
+    {
+      extern void _dl_runtime_resolve (void);
+      ElfW(Addr) *gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_RISCV (PLTGOT)]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      gotplt[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+      gotplt[1] = (ElfW(Addr)) l;
+      /* Relocate subsequent .got.plt entries. */
+      if (l->l_addr)
+	for (gotplt += 2; *gotplt; gotplt++)
+	  *gotplt += l->l_addr;
+    }
+
+# endif
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
diff --git a/glibc-2.14.1/sysdeps/riscv/dl-tls.h b/glibc-2.14.1/sysdeps/riscv/dl-tls.h
new file mode 100644
index 0000000..8c77a70
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/dl-tls.h
@@ -0,0 +1,49 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* The thread pointer points to the first static TLS block.  */
+#define TLS_TP_OFFSET		0
+
+/* Dynamic thread vector pointers point 0x8000 past the start of each
+   TLS block.  */
+#define TLS_DTV_OFFSET		0x800
+
+/* Compute the value for a GOTTPREL reloc.  */
+#define TLS_TPREL_VALUE(sym_map, sym) \
+  ((sym_map)->l_tls_offset + (sym)->st_value - TLS_TP_OFFSET)
+
+/* Compute the value for a DTPREL reloc.  */
+#define TLS_DTPREL_VALUE(sym) \
+  ((sym)->st_value - TLS_DTV_OFFSET)
+
+extern void *__tls_get_addr (tls_index *ti);
+
+# define GET_ADDR_OFFSET	(ti->ti_offset + TLS_DTV_OFFSET)
+# define __TLS_GET_ADDR(__ti)	(__tls_get_addr (__ti) - TLS_DTV_OFFSET)
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED	((void *) -1l)
diff --git a/glibc-2.14.1/sysdeps/riscv/dl-trampoline.S b/glibc-2.14.1/sysdeps/riscv/dl-trampoline.S
new file mode 100644
index 0000000..2fdd45a
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/dl-trampoline.S
@@ -0,0 +1,39 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* Assembler veneer called from the PLT header code for lazy loading.
+   The PLT header passes its own args in t0-t2. */
+
+ENTRY(_dl_runtime_resolve)
+  # Save arguments to stack.
+  addi sp, sp, -10*SZREG
+  REG_S ra, 9*SZREG(sp)
+  REG_S a0, 1*SZREG(sp)
+  REG_S a1, 2*SZREG(sp)
+  REG_S a2, 3*SZREG(sp)
+  REG_S a3, 4*SZREG(sp)
+  REG_S a4, 5*SZREG(sp)
+  REG_S a5, 6*SZREG(sp)
+  REG_S a6, 7*SZREG(sp)
+  REG_S a7, 8*SZREG(sp)
+
+  # Update .got.plt and obtain runtime address of callee.
+  mv a0, t0       # link map
+  slli a1, t1, 1  # reloc offset (== twice the .got.plt offset)
+  jal _dl_fixup
+
+  # Restore arguments from stack.
+  REG_L ra, 9*SZREG(sp)
+  REG_L a0, 1*SZREG(sp)
+  REG_L a1, 2*SZREG(sp)
+  REG_L a2, 3*SZREG(sp)
+  REG_L a3, 4*SZREG(sp)
+  REG_L a4, 5*SZREG(sp)
+  REG_L a5, 6*SZREG(sp)
+  REG_L a6, 7*SZREG(sp)
+  REG_L a7, 8*SZREG(sp)
+  addi sp, sp, 10*SZREG
+
+  # Invoke the callee.
+  jr v0
+END(_dl_runtime_resolve)
diff --git a/glibc-2.14.1/sysdeps/riscv/elf/configure b/glibc-2.14.1/sysdeps/riscv/elf/configure
new file mode 100644
index 0000000..961d9c8
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/elf/configure
@@ -0,0 +1,128 @@
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/riscv/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for RISC-V TLS support" >&5
+$as_echo_n "checking for RISC-V TLS support... " >&6; }
+if ${libc_cv_riscv_tls+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat > conftest.s <<\EOF
+	.section ".tdata", "awT", %progbits
+	.globl foo
+foo:	.long	1
+	.section ".tbss", "awT", %nobits
+	.globl bar
+bar:	.skip	4
+	.text
+
+	la		v0, __tls_get_addr
+	la.tls.gd	a0, x
+	jalr		v0
+EOF
+if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+  libc_cv_riscv_tls=yes
+else
+  libc_cv_riscv_tls=no
+fi
+rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_riscv_tls" >&5
+$as_echo "$libc_cv_riscv_tls" >&6; }
+if test $libc_cv_riscv_tls = yes; then
+  $as_echo "#define HAVE_TLS_SUPPORT 1" >>confdefs.h
+
+fi
+fi
+
+$as_echo "#define PI_STATIC_AND_HIDDEN 1" >>confdefs.h
+
diff --git a/glibc-2.14.1/sysdeps/riscv/elf/configure.in b/glibc-2.14.1/sysdeps/riscv/elf/configure.in
new file mode 100644
index 0000000..6ca00db
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/elf/configure.in
@@ -0,0 +1,33 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/riscv/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for RISC-V TLS support, libc_cv_riscv_tls, [dnl
+cat > conftest.s <<\EOF
+	.section ".tdata", "awT", %progbits
+	.globl foo
+foo:	.long	1
+	.section ".tbss", "awT", %nobits
+	.globl bar
+bar:	.skip	4
+	.text
+
+	la		v0, __tls_get_addr
+	la.tls.gd	a0, x
+	jalr		v0
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_riscv_tls=yes
+else
+  libc_cv_riscv_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_riscv_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
+
+AC_DEFINE(PI_STATIC_AND_HIDDEN)
diff --git a/glibc-2.14.1/sysdeps/riscv/elf/start.S b/glibc-2.14.1/sysdeps/riscv/elf/start.S
new file mode 100644
index 0000000..55deb45
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/elf/start.S
@@ -0,0 +1,98 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for start.S on MIPS/ELF.
+#endif
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/Mips ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   v0 ($2)	Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp ($29)	The stack contains the arguments and environment:
+		0(%esp)			argc
+		4(%esp)			argv[0]
+		...
+		(4*argc)(%esp)		NULL
+		(4*(argc+1))(%esp)	envp[0]
+		...
+					NULL
+   ra ($31)	The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+
+/* We need to call:
+   __libc_start_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+	
+	.text
+	.globl ENTRY_POINT
+	.type ENTRY_POINT,@function
+ENTRY_POINT:
+	la    gp, _gp
+	la    a0, main
+	REG_L a1, 0(sp)      /* argc */
+	addi  a2, sp, SZREG  /* argv */
+	andi  sp, sp, ALMASK /* Align stack. */
+	la    a3, __libc_csu_init
+	la    a4, __libc_csu_fini
+	move  a5, v0  /* rtld_fini */
+	move  a6, sp  /* stack_end */
+	
+	jump  __libc_start_main
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/bits/mathinline.h b/glibc-2.14.1/sysdeps/riscv/fpu/bits/mathinline.h
new file mode 100644
index 0000000..3c8a33d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/bits/mathinline.h
@@ -0,0 +1,66 @@
+/* Inline math functions for RISC-V.
+   Copyright (C) 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#ifdef __GNUC__
+
+#if defined __USE_ISOC99
+# undef isgreater
+# undef isgreaterequal
+# undef isless
+# undef islessequal
+# undef islessgreater
+# undef isunordered
+
+# define isgreater(x, y) ((x) > (y))
+# define isgreaterequal(x, y) ((x) >= (y))
+# define isless(x, y) ((x) < (y))
+# define islessequal(x, y) ((x) <= (y))
+# define islessgreater(x, y) (!!(isless(x, y) + isgreater(x, y)))
+# define isunordered(x, y) (((x) == (x)) + ((y) == (y)) < 2)
+
+extern inline int __attribute_used__ __signbit (double __x)
+{
+  union { double __d; long __i[sizeof(double)/sizeof(long)]; } __u;
+  __u.__d = __x;
+  return __u.__i[sizeof(double)/sizeof(long)-1] < 0;
+}
+
+extern inline int __attribute_used__ __signbitf (float __x)
+{
+  union { float __d; int __i; } __u;
+  __u.__d = __x;
+  return __u.__i < 0;
+}
+
+#endif /* __USE_ISOC99 */
+
+#if (!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) && defined __OPTIMIZE__
+
+/* Nothing yet. */
+
+#endif /* !__NO_MATH_INLINES && __OPTIMIZE__ */
+#endif /* __GNUC__ */
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fclrexcpt.c b/glibc-2.14.1/sysdeps/riscv/fpu/fclrexcpt.c
new file mode 100644
index 0000000..746dad9
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fclrexcpt.c
@@ -0,0 +1,29 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feclearexcept (int excepts)
+{
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  return 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fedisblxcpt.c b/glibc-2.14.1/sysdeps/riscv/fpu/fedisblxcpt.c
new file mode 100644
index 0000000..25eaee5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fedisblxcpt.c
@@ -0,0 +1,29 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fedisableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/feenablxcpt.c b/glibc-2.14.1/sysdeps/riscv/fpu/feenablxcpt.c
new file mode 100644
index 0000000..761c58d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/feenablxcpt.c
@@ -0,0 +1,29 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feenableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return -1;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fegetenv.c b/glibc-2.14.1/sysdeps/riscv/fpu/fegetenv.c
new file mode 100644
index 0000000..da5d597
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetenv.c
@@ -0,0 +1,32 @@
+/* Store current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetenv (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (fegetenv)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fegetexcept.c b/glibc-2.14.1/sysdeps/riscv/fpu/fegetexcept.c
new file mode 100644
index 0000000..bdb4b7d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetexcept.c
@@ -0,0 +1,29 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexcept (void)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fegetround.c b/glibc-2.14.1/sysdeps/riscv/fpu/fegetround.c
new file mode 100644
index 0000000..47eb92f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetround.c
@@ -0,0 +1,30 @@
+/* Return current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetround (void)
+{
+  int round;
+  _FPU_GETROUND (round);
+  return round;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/feholdexcpt.c b/glibc-2.14.1/sysdeps/riscv/fpu/feholdexcpt.c
new file mode 100644
index 0000000..3d8fa22
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/feholdexcpt.c
@@ -0,0 +1,32 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feholdexcept (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+  _FPU_SETFLAGS (0);
+  return 0;
+}
+
+libm_hidden_def (feholdexcept)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fesetenv.c b/glibc-2.14.1/sysdeps/riscv/fpu/fesetenv.c
new file mode 100644
index 0000000..e34fdaf
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fesetenv.c
@@ -0,0 +1,31 @@
+/* Install given floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetenv (const fenv_t *envp)
+{
+  _FPU_SETCW (envp == FE_DFL_ENV ? 0 : *envp);
+  return 0;
+}
+
+libm_hidden_def (fesetenv)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fesetround.c b/glibc-2.14.1/sysdeps/riscv/fpu/fesetround.c
new file mode 100644
index 0000000..ad80465
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fesetround.c
@@ -0,0 +1,34 @@
+/* Set current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetround (int round)
+{
+  int fail = round != FE_TONEAREST && round != FE_TOWARDZERO
+	     && round != FE_DOWNWARD && round != FE_UPWARD;
+  if (!fail)
+    _FPU_SETROUND (round);
+  return fail;
+}
+
+libm_hidden_def (fesetround)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/feupdateenv.c b/glibc-2.14.1/sysdeps/riscv/fpu/feupdateenv.c
new file mode 100644
index 0000000..51611cd
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/feupdateenv.c
@@ -0,0 +1,35 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feupdateenv (const fenv_t *envp)
+{
+  fenv_t env = *envp;
+
+  /* rm = 0; rm |= fenv.rm; flags |= fenv.flags */
+  _FPU_SETROUND (0);
+  asm volatile ("csrs fcsr, %0" : : "r"(env));
+
+  return 0;
+}
+libm_hidden_def (feupdateenv)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fgetexcptflg.c b/glibc-2.14.1/sysdeps/riscv/fpu/fgetexcptflg.c
new file mode 100644
index 0000000..537f5b7
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fgetexcptflg.c
@@ -0,0 +1,35 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  fpu_control_t temp;
+
+  /* Get the current exceptions.  */
+  _FPU_GETFLAGS (*flagp);
+  *flagp &= excepts;
+
+  /* Success.  */
+  return 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fraiseexcpt.c b/glibc-2.14.1/sysdeps/riscv/fpu/fraiseexcpt.c
new file mode 100644
index 0000000..2a839d0
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fraiseexcpt.c
@@ -0,0 +1,31 @@
+/* Raise given exceptions.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feraiseexcept (int excepts)
+{
+  asm volatile ("csrs fflags, %0" : : "r"(excepts));
+  return 0;
+}
+
+libm_hidden_def (feraiseexcept)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/fsetexcptflg.c b/glibc-2.14.1/sysdeps/riscv/fpu/fsetexcptflg.c
new file mode 100644
index 0000000..c28235a
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/fsetexcptflg.c
@@ -0,0 +1,32 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fexcept_t flags = *flagp;
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  asm volatile ("csrs fflags, %0" : : "r"(flags & excepts));
+
+  return 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/ftestexcept.c b/glibc-2.14.1/sysdeps/riscv/fpu/ftestexcept.c
new file mode 100644
index 0000000..8235fa1
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/ftestexcept.c
@@ -0,0 +1,33 @@
+/* Test exception in current environment.
+   Copyright (C) 1998, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fetestexcept (int excepts)
+{
+  int cw;
+
+  _FPU_GETFLAGS (cw);
+
+  return cw & excepts;
+}
+libm_hidden_def (fetestexcept)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/libm-test-ulps b/glibc-2.14.1/sysdeps/riscv/fpu/libm-test-ulps
new file mode 100644
index 0000000..b514496
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/libm-test-ulps
@@ -0,0 +1,890 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacosh
+Test "Real part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# catan
+Test "Real part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+float: 3
+ifloat: 3
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+float: 4
+ifloat: 4
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Imaginary part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+float: 4
+ifloat: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+float: 6
+ifloat: 6
+
+# cbrt
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+
+# clog
+Test "Imaginary part of: clog (-2 - 3 i) == 1.2824746787307683680267437207826593 - 2.1587989303424641704769327722648368 i":
+float: 3
+ifloat: 3
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+float: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "cos (pi/2) == 0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+# csinh
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+float: 1
+ifloat: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+
+# j1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/2, &sin_res, &cos_res) puts 0 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# tan
+Test "tan (pi/4) == 1":
+double: 1
+idouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 3
+ifloat: 3
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cacosh":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+
+Function: Real part of "catan":
+float: 4
+ifloat: 4
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+
+Function: Imaginary part of "catanh":
+float: 6
+ifloat: 6
+
+Function: "cbrt":
+double: 1
+idouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog":
+float: 3
+ifloat: 3
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+
+Function: Real part of "ctan":
+double: 1
+idouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log1p":
+float: 1
+ifloat: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+# end of automatic generation
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_copysign.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_copysign.c
new file mode 100644
index 0000000..32dc5dc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_copysign.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __copysign(double x, double y)
+{
+  double res;
+  asm ("fsgnj.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysign, copysign)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_copysignf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_copysignf.c
new file mode 100644
index 0000000..11d493b
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_copysignf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __copysignf(float x, float y)
+{
+  float res;
+  asm ("fsgnj.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysignf, copysignf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fabs.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fabs.c
new file mode 100644
index 0000000..95f5b28
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fabs.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __fabs(double x)
+{
+  double res;
+  asm ("fabs.d %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabs, fabs)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fabsf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fabsf.c
new file mode 100644
index 0000000..9df4ae6
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fabsf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __fabsf(float x)
+{
+  float res;
+  asm ("fabs.s %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabsf, fabsf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fdim.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fdim.c
new file mode 100644
index 0000000..9835f59
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fdim.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+double __fdim (double x, double y)
+{
+  double diff = x - y;
+  
+  if (x <= y)
+    return 0.0;
+
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+
+  return diff;
+}
+weak_alias (__fdim, fdim)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fdimf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fdimf.c
new file mode 100644
index 0000000..480136c
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fdimf.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+float __fdimf (float x, float y)
+{
+  float diff = x - y;
+  
+  if (x <= y)
+    return 0.0f;
+
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+
+  return diff;
+}
+weak_alias (__fdimf, fdimf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_finite.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_finite.c
new file mode 100644
index 0000000..bf2135b
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_finite.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finite(double x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finite)
+weak_alias (__finite, finite)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_finitef.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_finitef.c
new file mode 100644
index 0000000..6448d2d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_finitef.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finitef(float x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finitef)
+weak_alias (__finitef, finitef)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fma.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fma.c
new file mode 100644
index 0000000..797bc7d
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fma.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+double __fma (double x, double y, double z)
+{
+  double out;
+  asm volatile ("fmadd.d %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fma, fma)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fmaf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fmaf.c
new file mode 100644
index 0000000..11775f9
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fmaf.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+float __fmaf (float x, float y, float z)
+{
+  float out;
+  asm volatile ("fmadd.s %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fmaf, fmaf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fmax.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fmax.c
new file mode 100644
index 0000000..8d2e662
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fmax.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+double __fmax (double x, double y)
+{
+  double res;
+  asm ("fmax.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmax, fmax)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fmaxf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fmaxf.c
new file mode 100644
index 0000000..aa62172
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fmaxf.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+float __fmaxf (float x, float y)
+{
+  float res;
+  asm ("fmax.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmaxf, fmaxf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fmin.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fmin.c
new file mode 100644
index 0000000..e4e37df
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fmin.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+double __fmin (double x, double y)
+{
+  double res;
+  asm ("fmin.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fmin, fmin)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fminf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fminf.c
new file mode 100644
index 0000000..5d25bc2
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fminf.c
@@ -0,0 +1,9 @@
+#include <math.h>
+
+float __fminf (float x, float y)
+{
+  float res;
+  asm ("fmin.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__fminf, fminf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassify.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassify.c
new file mode 100644
index 0000000..2b58c3f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassify.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassify (double x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassify)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassifyf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassifyf.c
new file mode 100644
index 0000000..fae20fa
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_fpclassifyf.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassifyf (float x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassifyf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_isinf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_isinf.c
new file mode 100644
index 0000000..339d97f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_isinf.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinf(double x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinf)
+weak_alias (__isinf, isinf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_isinff.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_isinff.c
new file mode 100644
index 0000000..501342e
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_isinff.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinff(float x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinff)
+weak_alias (__isinff, isinff)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_isnan.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_isnan.c
new file mode 100644
index 0000000..dcbb629
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_isnan.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnan(double x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnan)
+weak_alias (__isnan, isnan)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_isnanf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_isnanf.c
new file mode 100644
index 0000000..78e9d0c
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_isnanf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnanf(float x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnanf)
+weak_alias (__isnanf, isnanf)
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_signbit.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_signbit.c
new file mode 100644
index 0000000..5f99c3f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_signbit.c
@@ -0,0 +1,18 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbit (double x)
+{
+#ifdef __riscv64
+  int64_t hx;
+  EXTRACT_WORDS64 (hx, x);
+  return hx < 0;
+#else
+  int32_t hx;
+  GET_HIGH_WORD (hx, x);
+  return hx < 0;
+#endif
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu/s_signbitf.c b/glibc-2.14.1/sysdeps/riscv/fpu/s_signbitf.c
new file mode 100644
index 0000000..6e25688
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu/s_signbitf.c
@@ -0,0 +1,12 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbitf (float x)
+{
+  int32_t hx;
+  GET_FLOAT_WORD (hx, x);
+  return hx < 0;
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/fpu_control.h b/glibc-2.14.1/sysdeps/riscv/fpu_control.h
new file mode 100644
index 0000000..4c36db5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/fpu_control.h
@@ -0,0 +1,92 @@
+/* FPU control word bits.  Mips version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe and Ralf Baechle.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+#include <features.h>
+
+#ifdef __riscv_soft_float
+
+#define _FPU_RESERVED 0xffffffff
+#define _FPU_DEFAULT  0x00000000
+typedef unsigned int fpu_control_t;
+#define _FPU_GETCW(cw) 0
+#define _FPU_SETCW(cw) do { } while (0)
+extern fpu_control_t __fpu_control;
+
+#else /* __mips_soft_float */
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_DOWN    0x2
+#define _FPU_RC_UP      0x3
+
+#define _FPU_RESERVED   0    /* No reserved bits in FSR */
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0
+
+/* IEEE:  same as above */
+#define _FPU_IEEE     _FPU_DEFAULT
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ volatile ("frsr %0" : "=r" (cw))
+#define _FPU_GETROUND(cw) __asm__ volatile ("frrm %0" : "=r" (cw))
+#define _FPU_GETFLAGS(cw) __asm__ volatile ("frflags %0" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ volatile ("fssr %z0" : : "rJ" (cw))
+#define _FPU_SETROUND(cw) __asm__ volatile ("fsrm %z0" : : "rJ" (cw))
+#define _FPU_SETFLAGS(cw) __asm__ volatile ("fsflags %z0" : : "rJ" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#define _FCLASS(x) ({ int res; \
+  if (sizeof(x) == 4) asm ("fclass.s %0, %1" : "=r"(res) : "f"(x)); \
+  else if (sizeof(x) == 8) asm ("fclass.d %0, %1" : "=r"(res) : "f"(x)); \
+  else abort(); \
+  res; })
+
+#define _FCLASS_MINF     (1<<0)
+#define _FCLASS_MNORM    (1<<1)
+#define _FCLASS_MSUBNORM (1<<2)
+#define _FCLASS_MZERO    (1<<3)
+#define _FCLASS_PZERO    (1<<4)
+#define _FCLASS_PSUBNORM (1<<5)
+#define _FCLASS_PNORM    (1<<6)
+#define _FCLASS_PINF     (1<<7)
+#define _FCLASS_SNAN     (1<<8)
+#define _FCLASS_QNAN     (1<<9)
+#define _FCLASS_ZERO     (_FCLASS_MZERO | _FCLASS_PZERO)
+#define _FCLASS_SUBNORM  (_FCLASS_MSUBNORM | _FCLASS_PSUBNORM)
+#define _FCLASS_NORM     (_FCLASS_MNORM | _FCLASS_PNORM)
+#define _FCLASS_INF      (_FCLASS_MINF | _FCLASS_PINF)
+#define _FCLASS_NAN      (_FCLASS_SNAN | _FCLASS_QNAN)
+
+#endif /* __mips_soft_float */
+
+#endif	/* fpu_control.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/gccframe.h b/glibc-2.14.1/sysdeps/riscv/gccframe.h
new file mode 100644
index 0000000..ec9311c
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/gccframe.h
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  mips version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define FIRST_PSEUDO_REGISTER 76
+
+#include <sysdeps/generic/gccframe.h>
diff --git a/glibc-2.14.1/sysdeps/riscv/ieee754.h b/glibc-2.14.1/sysdeps/riscv/ieee754.h
new file mode 100644
index 0000000..912e088
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/ieee754.h
@@ -0,0 +1,325 @@
+/* Copyright (C) 1992, 1995, 1996, 1999, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _IEEE754_H
+
+#define _IEEE754_H 1
+#include <features.h>
+
+#include <endian.h>
+
+#include <float.h>
+
+__BEGIN_DECLS
+
+union ieee754_float
+  {
+    float f;
+
+    /* This is the IEEE 754 single-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int mantissa:23;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:23;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa:22;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:22;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
+
+
+union ieee754_double
+  {
+    double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#if LDBL_MANT_DIG == 113
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 quad-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:16;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:16;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:15;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:15;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff /* Added to exponent.  */
+
+#elif LDBL_MANT_DIG == 64
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:32;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee;
+
+    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int one:1;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa0:30;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
+
+#elif LDBL_MANT_DIG == 53
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#endif /* LDBL_MANT_DIG == 53 */
+
+__END_DECLS
+
+#endif /* ieee754.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/jmpbuf-unwind.h b/glibc-2.14.1/sysdeps/riscv/jmpbuf-unwind.h
new file mode 100644
index 0000000..bfa1a64
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/jmpbuf-unwind.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/glibc-2.14.1/sysdeps/riscv/ldsodefs.h b/glibc-2.14.1/sysdeps/riscv/ldsodefs.h
new file mode 100644
index 0000000..8820a08
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/ldsodefs.h
@@ -0,0 +1,70 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2000, 2002, 2003, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_LDSODEFS_H
+#define _MIPS_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_mips_32_regs;
+struct La_mips_32_retval;
+struct La_mips_64_regs;
+struct La_mips_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						    \
+    Elf32_Addr (*mips_o32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_32_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf32_Addr (*mips_n32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf64_Addr (*mips_n64_gnu_pltenter) (Elf64_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						    \
+    unsigned int (*mips_o32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_32_regs *,   \
+					  struct La_mips_32_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n64_gnu_pltexit) (Elf64_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);
+
+/* The MIPS ABI specifies that the dynamic section has to be read-only.  */
+
+#define DL_RO_DYN_SECTION 1
+
+#include_next <ldsodefs.h>
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/libc-tls.c b/glibc-2.14.1/sysdeps/riscv/libc-tls.c
new file mode 100644
index 0000000..a3d6301
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/libc-tls.c
@@ -0,0 +1,37 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On MIPS, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + GET_ADDR_OFFSET;
+}
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/memcpy.c b/glibc-2.14.1/sysdeps/riscv/memcpy.c
new file mode 100644
index 0000000..3706ba6
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/memcpy.c
@@ -0,0 +1,65 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef memcpy
+#undef __memcpy_g
+
+void* __memcpy_g(void* aa, const void* bb, size_t n)
+{
+  #define BODY(a, b, t) { \
+    t tt = *b; \
+    a++, b++; \
+    *(a-1) = tt; \
+  }
+
+  char* a = (char*)aa;
+  const char* b = (const char*)bb;
+  char* end = a+n;
+  uintptr_t msk = sizeof(long)-1;
+  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
+  {
+foo:
+    if (__builtin_expect(a < end, 1))
+      while (a < end)
+        BODY(a, b, char);
+    return aa;
+  }
+
+  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
+    while ((uintptr_t)a & msk)
+      BODY(a, b, char);
+
+  long* __restrict__ la = (long*)a;
+  const long* __restrict__ lb = (const long*)b;
+  long* lend = (long*)((uintptr_t)end & ~msk);
+
+  if (__builtin_expect(la < lend-8, 0))
+  {
+    while (la < lend-8)
+    {
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+      *la++ = *lb++;
+    }
+    if (la == lend)
+      goto bar;
+  }
+
+  do BODY(la, lb, long) while (la < lend);
+
+bar:
+  a = (char*)la;
+  b = (const char*)lb;
+  if (__builtin_expect(a < end, 0))
+    goto foo;
+  return aa;
+}
+libc_hidden_def (__memcpy_g)
+strong_alias (__memcpy_g, memcpy)
+libc_hidden_builtin_def (memcpy)
diff --git a/glibc-2.14.1/sysdeps/riscv/memset.c b/glibc-2.14.1/sysdeps/riscv/memset.c
new file mode 100644
index 0000000..cfde2fe
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/memset.c
@@ -0,0 +1,43 @@
+typedef unsigned long size_t;
+//#include <string.h>
+
+void* memset(void* dst, int val, size_t n)
+{
+  void* dst0 = dst;
+  void* end = dst + n;
+  unsigned char v = val;
+
+  /* is dst word-aligned? */
+  if (((long)dst & (sizeof(long)-1)) == 0)
+  {
+    long lval = v;
+    lval |= lval << 8;
+    lval |= lval << 16;
+    #ifdef __riscv64
+    lval |= lval << 32;
+    #elif !defined(__riscv32)
+    # error
+    #endif
+
+    /* set 4 words at a time */
+    for ( ; dst <= end - 4*sizeof(long); dst += 4*sizeof(long))
+    {
+      *(long*)(dst+0*sizeof(long)) = lval;
+      *(long*)(dst+1*sizeof(long)) = lval;
+      *(long*)(dst+2*sizeof(long)) = lval;
+      *(long*)(dst+3*sizeof(long)) = lval;
+    }
+
+    /* set a word at a time */
+    for ( ; dst <= end - sizeof(long); dst += sizeof(long))
+      *(long*)dst = lval;
+  }
+
+  /* set a byte at a time */
+  for ( ; dst < end; dst++)
+    *(unsigned char*)dst = v;
+
+  return dst0;
+}
+
+weak_alias (memset, __GI_memset)
diff --git a/glibc-2.14.1/sysdeps/riscv/memusage.h b/glibc-2.14.1/sysdeps/riscv/memusage.h
new file mode 100644
index 0000000..c558a06
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/memusage.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("sp"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/Makefile b/glibc-2.14.1/sysdeps/riscv/nptl/Makefile
new file mode 100644
index 0000000..d0c59a5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/Makefile
@@ -0,0 +1,25 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+libpthread-sysdep_routines += nptl-sysdep
+endif
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/nptl-sysdep.c b/glibc-2.14.1/sysdeps/riscv/nptl/nptl-sysdep.c
new file mode 100644
index 0000000..16c1736
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/nptl-sysdep.c
@@ -0,0 +1,2 @@
+/* Pull in __syscall_error.  */
+#include <sysdep.c>
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_destroy.c b/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_destroy.c
new file mode 100644
index 0000000..e1eed80
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_destroy.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+#ifndef __riscv_atomic
+int
+pthread_spin_destroy (lock)
+     pthread_spinlock_t *lock;
+{
+  return pthread_mutex_destroy(lock);
+}
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_init.c b/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_init.c
new file mode 100644
index 0000000..b85181a
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_init.c
@@ -0,0 +1,30 @@
+/* pthread_spin_init -- initialize a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+#ifndef __riscv_atomic
+int
+pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  return pthread_mutex_init(lock, NULL);
+}
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_lock.c b/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_lock.c
new file mode 100644
index 0000000..0e8840b
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_lock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_lock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+  1:lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1b\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+    bnez         %0, 1b"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_lock(lock);
+#endif
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_trylock.c b/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_trylock.c
new file mode 100644
index 0000000..b19ec5e
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_trylock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_trylock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+    lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1f\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+  1:"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_trylock(lock);
+#endif
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_unlock.c b/glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_unlock.c
new file mode 100644
index 0000000..133311c
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_unlock.c
@@ -0,0 +1,33 @@
+/* pthread_spin_unlock -- unlock a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <atomic.h>
+
+int
+pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+#ifdef __riscv_atomic
+  asm volatile ("amoswap.w.rl x0, x0, 0(%0)" : : "r"(lock));
+  return 0;
+#else
+  return pthread_mutex_unlock(lock);
+#endif
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/pthreaddef.h b/glibc-2.14.1/sysdeps/riscv/nptl/pthreaddef.h
new file mode 100644
index 0000000..e72b4bc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthreaddef.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/tcb-offsets.sym b/glibc-2.14.1/sysdeps/riscv/nptl/tcb-offsets.sym
new file mode 100644
index 0000000..e0e71dc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/glibc-2.14.1/sysdeps/riscv/nptl/tls.h b/glibc-2.14.1/sysdeps/riscv/nptl/tls.h
new file mode 100644
index 0000000..5297ff8
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/nptl/tls.h
@@ -0,0 +1,164 @@
+/* Definition for thread-local data handling.  NPTL/MIPS version.
+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+register void* __thread_self asm("tp");
+# define READ_THREAD_POINTER() ({ __thread_self; })
+
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer tp points to the end of the TCB.
+   The pthread_descr structure is immediately in front of the TCB. */
+# define TLS_TCB_OFFSET	0
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer. */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __thread_self = (char*)tcbp + TLS_TCB_OFFSET; NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* l_tls_offset == 0 is perfectly valid on MIPS, so we have to use some
+   different value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/preconfigure b/glibc-2.14.1/sysdeps/riscv/preconfigure
new file mode 100644
index 0000000..c3792e1
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/preconfigure
@@ -0,0 +1,21 @@
+ccccase "$CC $CFLAGS $CPPFLAGS " in
+*" -m32 "*) mips_cc_abi=32 ;;
+*" -m64 "*) mips_cc_abi=64 ;;
+*) mips_cc_abi=default ;;
+esac
+case $config_os in
+*abi64*) mips_config_abi=64 ;;
+*abi32*) mips_config_abi=32 ;;
+*) mips_config_abi=$mips_cc_abi ;;
+esac
+case $mips_config_abi in
+default) machine=riscv/rv64 ;;
+32) machine=riscv/rv32 ;;
+esac
+machine=$machine/$config_machine
+if test $mips_config_abi != $mips_cc_abi; then
+  # This won't make it to config.make, but we want to
+  # set this in case configure tests depend on it.
+  CPPFLAGS="$CPPFLAGS -m$mips_config_abi"
+fi
+;;
diff --git a/glibc-2.14.1/sysdeps/riscv/rv32/Implies b/glibc-2.14.1/sysdeps/riscv/rv32/Implies
new file mode 100644
index 0000000..b2313e9
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv32/Implies
@@ -0,0 +1,2 @@
+riscv
+wordsize-32
diff --git a/glibc-2.14.1/sysdeps/riscv/rv32/Makefile b/glibc-2.14.1/sysdeps/riscv/rv32/Makefile
new file mode 100644
index 0000000..f9c69e3
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(filter -m32,$(CC)),)
+CC += -m32
+endif
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/Implies b/glibc-2.14.1/sysdeps/riscv/rv64/Implies
new file mode 100644
index 0000000..fae63bc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/Implies
@@ -0,0 +1,6 @@
+ieee754/flt-32
+ieee754/dbl-64
+riscv/rv64/soft-fp
+riscv/rv64
+riscv
+wordsize-64
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/Makefile b/glibc-2.14.1/sysdeps/riscv/rv64/Makefile
new file mode 100644
index 0000000..26b6a49
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/Makefile
@@ -0,0 +1,6 @@
+# Link libc.so at its likely load address for faster dynamic linking
+LDLIBS-c.so += -Wl,--section-start=.dynamic=0x40100270
+
+ifeq ($(filter -m64,$(CC)),)
+CC += -m64
+endif
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/Versions b/glibc-2.14.1/sysdeps/riscv/rv64/Versions
new file mode 100644
index 0000000..253a65f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/Versions
@@ -0,0 +1,7 @@
+libm {
+  GLIBC_2.1 {
+    # A generic bug got this omitted from other configurations' version
+    # sets, but we always had it.
+    exp2l;
+  }
+}
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/gmp-mparam.h b/glibc-2.14.1/sysdeps/riscv/rv64/gmp-mparam.h
new file mode 100644
index 0000000..7666137
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/gmp-mparam.h
@@ -0,0 +1,31 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 1991, 1993, 1994, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/libm-test-ulps b/glibc-2.14.1/sysdeps/riscv/rv64/libm-test-ulps
new file mode 100644
index 0000000..d9df631
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/libm-test-ulps
@@ -0,0 +1,1245 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994379639112":
+ildouble: 1
+ldouble: 1
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacos
+Test "Imaginary part of: cacos (0.75 + 1.25 i) == 1.11752014915610270578240049553777969 - 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# cacosh
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# catan
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+ildouble: 1
+ldouble: 1
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+ildouble: 1
+ldouble: 1
+
+# cbrt
+Test "cbrt (-0.001) == -0.1":
+ildouble: 1
+ldouble: 1
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Real part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Real part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+ildouble: 1
+ldouble: 1
+
+# clog
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + inf i) == inf + 3/4 pi*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 4
+ldouble: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+ildouble: 10
+ldouble: 10
+Test "Real part of: cpow (2 + 0 i, 10 + 0 i) == 1024.0 + 0.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# csin
+Test "Imaginary part of: csin (-2 - 3 i) == -9.15449914691142957346729954460983256 + 4.16890695996656435075481305885375484 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 1.25 i) == 1.28722291002649188575873510790565441 + 1.17210635989270256101081285116138863 i":
+ildouble: 1
+ldouble: 1
+
+# csinh
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0.75 + 1.25 i) == 1.05065169626078392338656675760808326 + 0.594868882070379067881984030639932657 i":
+ildouble: 1
+ldouble: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (27.0) == 0.523704892378925568501606768284954709e-318":
+ildouble: 1
+ldouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# exp2
+Test "exp2 (10) == 1024":
+ildouble: 2
+ldouble: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# gamma
+Test "gamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# j1
+Test "j1 (-1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "j1 (1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (1, -1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+Test "jn (10, -1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+ildouble: 2
+ldouble: 2
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# log2
+Test "log2 (0.75) == -.415037499278843818546261056052183492":
+ildouble: 1
+ldouble: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# sqrt
+Test "sqrt (2) == M_SQRT2l":
+ildouble: 1
+ldouble: 1
+
+# tanh
+Test "tanh (-0.75) == -0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (-1.0) == -0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+Test "tanh (0.75) == 0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (1.0) == 0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (4) == 6":
+ildouble: 1
+ldouble: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+ildouble: 2
+ldouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cacos":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "casin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+ildouble: 1
+ldouble: 1
+
+Function: "cbrt":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+ildouble: 10
+ldouble: 10
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csqrt":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctan":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "exp2":
+ildouble: 2
+ldouble: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "gamma":
+ildouble: 1
+ldouble: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 4
+ldouble: 4
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+ildouble: 4
+ldouble: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log1p":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "log2":
+ildouble: 1
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sqrt":
+ildouble: 1
+ldouble: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tanh":
+ildouble: 1
+ldouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 5
+ldouble: 5
+
+# end of automatic generation
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/Makefile b/glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/Makefile
new file mode 100644
index 0000000..ada13e8
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
diff --git a/glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/sfp-machine.h b/glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
new file mode 100644
index 0000000..0bf2776
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
@@ -0,0 +1,74 @@
+#include <fenv.h>
+#include <fpu_control.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long long
+#define _FP_WS_TYPE		signed long long
+#define _FP_I_TYPE		long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_DECL_EX		fpu_control_t _fcw
+
+#define FP_ROUNDMODE		(_fcw >> 5)
+
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#ifdef __mips_hard_float
+#define FP_INIT_ROUNDMODE			\
+do {						\
+  _FPU_GETCW (_fcw);				\
+} while (0)
+
+#define FP_HANDLE_EXCEPTIONS			\
+do {						\
+  if (__builtin_expect (_fex, 0))		\
+    _FPU_SETCW (_fcw | _fex);			\
+} while (0)
+#else
+#define FP_INIT_ROUNDMODE	_fcw = 0 /* no exceptions; FP_RND_NEAREST */
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/setjmp.S b/glibc-2.14.1/sysdeps/riscv/setjmp.S
new file mode 100644
index 0000000..07559c5
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/setjmp.S
@@ -0,0 +1,83 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (_setjmp)
+  li	a1, 0
+  j	__sigsetjmp
+END (_setjmp)
+ENTRY (setjmp)
+  li	a1, 1
+  /* Fallthrough */
+END (setjmp)
+ENTRY (__sigsetjmp)
+	REG_S ra,  0*SZREG(a0)
+	REG_S s0,  1*SZREG(a0)
+	REG_S s1,  2*SZREG(a0)
+	REG_S s2,  3*SZREG(a0)
+	REG_S s3,  4*SZREG(a0)
+	REG_S s4,  5*SZREG(a0)
+	REG_S s5,  6*SZREG(a0)
+	REG_S s6,  7*SZREG(a0)
+	REG_S s7,  8*SZREG(a0)
+	REG_S s8,  9*SZREG(a0)
+	REG_S s9, 10*SZREG(a0)
+	REG_S s10,11*SZREG(a0)
+	REG_S s11,12*SZREG(a0)
+	REG_S sp, 13*SZREG(a0)
+	REG_S tp, 14*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	frsr a3
+
+	fsd  fs0, 16*SZREG+ 0*8(a0)
+	fsd  fs1, 16*SZREG+ 1*8(a0)
+	fsd  fs2, 16*SZREG+ 2*8(a0)
+	fsd  fs3, 16*SZREG+ 3*8(a0)
+	fsd  fs4, 16*SZREG+ 4*8(a0)
+	fsd  fs5, 16*SZREG+ 5*8(a0)
+	fsd  fs6, 16*SZREG+ 6*8(a0)
+	fsd  fs7, 16*SZREG+ 7*8(a0)
+	fsd  fs8, 16*SZREG+ 8*8(a0)
+	fsd  fs9, 16*SZREG+ 9*8(a0)
+	fsd  fs10,16*SZREG+10*8(a0)
+	fsd  fs11,16*SZREG+11*8(a0)
+	fsd  fs12,16*SZREG+12*8(a0)
+	fsd  fs13,16*SZREG+13*8(a0)
+	fsd  fs14,16*SZREG+14*8(a0)
+	fsd  fs15,16*SZREG+15*8(a0)
+
+	REG_S a3, 15*SZREG(a0)
+#endif
+
+#if defined NOT_IN_libc && defined IS_IN_rtld
+  /* In ld.so we never save the signal mask.  */
+  li v0, 0
+  ret
+#else
+  /* Make a tail call to __sigjmp_save; it takes the same args.  */
+  j __sigjmp_save
+#endif
+
+
+END(__sigsetjmp)
+
+weak_alias(_setjmp, __GI__setjmp)
diff --git a/glibc-2.14.1/sysdeps/riscv/sgidefs.h b/glibc-2.14.1/sysdeps/riscv/sgidefs.h
new file mode 100644
index 0000000..34a6e61
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/sgidefs.h
@@ -0,0 +1,41 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SGIDEFS_H
+#define _SGIDEFS_H	1
+
+/*
+ * Subprogram calling convention
+ */
+#ifndef _ABIO32
+# define _ABIO32		1
+#endif
+#define _RISCV_SIM_ABI32		_ABIO32
+
+#ifndef _ABIN32
+# define _ABIN32		2
+#endif
+#define _RISCV_SIM_NABI32	_ABIN32
+
+#ifndef _ABI64
+# define _ABI64			3
+#endif
+#define _RISCV_SIM_ABI64		_ABI64
+
+#endif /* sgidefs.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/soft-fp/sfp-machine.h b/glibc-2.14.1/sysdeps/riscv/soft-fp/sfp-machine.h
new file mode 100644
index 0000000..3b2a40f
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/soft-fp/sfp-machine.h
@@ -0,0 +1,47 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
diff --git a/glibc-2.14.1/sysdeps/riscv/stackinfo.h b/glibc-2.14.1/sysdeps/riscv/stackinfo.h
new file mode 100644
index 0000000..7a5e3e0
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/stackinfo.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On MIPS the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif	/* stackinfo.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/strcmp.S b/glibc-2.14.1/sysdeps/riscv/strcmp.S
new file mode 100644
index 0000000..2db21ea
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/strcmp.S
@@ -0,0 +1,129 @@
+# Artisanally coded in California by A. Shell Waterman
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#if BYTE_ORDER != LITTLE_ENDIAN
+# error
+#endif
+
+ENTRY(strcmp)
+  or    v1, a0, a1
+  li    t2, -1
+  and   v1, v1, SZREG-1
+  li    v0, 0
+  bnez  v1, .Lmisaligned
+
+#if SZREG == 4
+  li t3, 0x7f7f7f7f
+#else
+  ld t3, mask
+#endif
+
+  .macro check_one_word i n
+    REG_L a2, \i*SZREG(a0)
+    REG_L a3, \i*SZREG(a1)
+
+    and   t0, a2, t3
+    or    t1, a2, t3
+    add   t0, t0, t3
+    or    t0, t0, t1
+
+    bne   t0, t2, .Lnull\i
+    .if \i+1-\n
+      bne   a2, a3, .Lmismatch
+    .else
+      add   a0, a0, \n*SZREG
+      add   a1, a1, \n*SZREG
+      beq   a2, a3, .Lloop
+      # fall through to .Lmismatch
+    .endif
+  .endm
+
+  .macro foundnull i n
+    .ifne \i
+      .Lnull\i:
+      add   a0, a0, \i*SZREG
+      add   a1, a1, \i*SZREG
+      .ifeq \i-1
+        .Lnull0:
+      .endif
+      bne   a2, a3, .Lmisaligned
+      ret
+    .endif
+  .endm
+
+.Lloop:
+  # examine full words
+  check_one_word 0 4
+  check_one_word 1 4
+  check_one_word 2 4
+  check_one_word 3 4
+  # backwards branch to .Lloop contained above
+
+.Lmismatch:
+  # words don't match, but a2 has no null byte.
+#ifdef __riscv64
+  sll   a0, a2, 48
+  sll   a1, a3, 48
+  bne   a0, a1, .Lmismatch_upper
+  sll   a0, a2, 32
+  sll   a1, a3, 32
+  bne   a0, a1, .Lmismatch_upper
+#endif
+  sll   a0, a2, 16
+  sll   a1, a3, 16
+  bne   a0, a1, .Lmismatch_upper
+
+  srl   a0, a2, 8*SZREG-16
+  srl   a1, a3, 8*SZREG-16
+  sub   v0, a0, a1
+  and   v1, v0, 0xff
+  bnez  v1, 1f
+  ret
+
+.Lmismatch_upper:
+  srl   a0, a0, 8*SZREG-16
+  srl   a1, a1, 8*SZREG-16
+  sub   v0, a0, a1
+  and   v1, v0, 0xff
+  bnez  v1, 1f
+  ret
+
+1:and   a0, a0, 0xff
+  and   a1, a1, 0xff
+  sub   v0, a0, a1
+  ret
+
+.Lmisaligned:
+  # misaligned
+  lbu   v0, 0(a0)
+  lbu   v1, 0(a1)
+  add   a0, a0, 1
+  add   a1, a1, 1
+  bne   v0, v1, 1f
+  bnez  v0, .Lmisaligned
+
+1:
+  sub   v0, v0, v1
+  ret
+
+  # cases in which a null byte was detected
+  foundnull 0, 4
+  foundnull 1, 4
+  foundnull 2, 4
+  foundnull 3, 4
+
+END(strcmp)
+
+weak_alias(strcmp, __GI_strcmp)
+
+#if SZREG == 8
+#ifdef __PIC__
+.section .rodata.cst8,"aM",@progbits,8
+#else
+.section .srodata.cst8,"aM",@progbits,8
+#endif
+.align 3
+mask: .8byte 0x7f7f7f7f7f7f7f7f
+#endif
diff --git a/glibc-2.14.1/sysdeps/riscv/strcpy.c b/glibc-2.14.1/sysdeps/riscv/strcpy.c
new file mode 100644
index 0000000..c01c506
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/strcpy.c
@@ -0,0 +1,54 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strcpy
+
+char* strcpy(char* dst, const char* src)
+{
+  char* dst0 = dst;
+
+  int misaligned = ((uintptr_t)dst | (uintptr_t)src) & (sizeof(long)-1);
+  if (__builtin_expect(!misaligned, 1))
+  {
+    long* ldst = (long*)dst;
+    const long* lsrc = (const long*)src;
+
+    while (!__libc_detect_null(*lsrc))
+      *ldst++ = *lsrc++;
+
+    dst = (char*)ldst;
+    src = (const char*)lsrc;
+
+    char c0 = src[0];
+    char c1 = src[1];
+    char c2 = src[2];
+    if (!(*dst++ = c0)) return dst0;
+    if (!(*dst++ = c1)) return dst0;
+    char c3 = src[3];
+    if (!(*dst++ = c2)) return dst0;
+    if (sizeof(long) == 4) goto out;
+    char c4 = src[4];
+    if (!(*dst++ = c3)) return dst0;
+    char c5 = src[5];
+    if (!(*dst++ = c4)) return dst0;
+    char c6 = src[6];
+    if (!(*dst++ = c5)) return dst0;
+    if (!(*dst++ = c6)) return dst0;
+
+out:
+    *dst++ = 0;
+    return dst0;
+  }
+
+  char ch;
+  do
+  {
+    ch = *src;
+    src++;
+    dst++;
+    *(dst-1) = ch;
+  } while(ch);
+
+  return dst0;
+}
+libc_hidden_def(strcpy)
diff --git a/glibc-2.14.1/sysdeps/riscv/strlen.c b/glibc-2.14.1/sysdeps/riscv/strlen.c
new file mode 100644
index 0000000..2630f46
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/strlen.c
@@ -0,0 +1,38 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strlen
+
+size_t strlen(const char* str)
+{
+  const char* start = str;
+
+  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
+  {
+    char ch = *str;
+    str++;
+    if (!ch)
+      return str - start - 1;
+  } while ((uintptr_t)str & (sizeof(long)-1));
+
+  unsigned long* ls = (unsigned long*)str;
+  while (!__libc_detect_null(*ls++))
+    ;
+  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */
+
+  str = (const char*)ls;
+  size_t ret = str - start, sl = sizeof(long);
+
+  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
+  if (c0 == 0)            return ret + 0 - sl;
+  if (c1 == 0)            return ret + 1 - sl;
+  if (c2 == 0)            return ret + 2 - sl;
+  if (sl == 4 || c3 == 0) return ret + 3 - sl;
+
+  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
+  if (c0 == 0)            return ret + 4 - sl;
+  if (c1 == 0)            return ret + 5 - sl;
+  if (c2 == 0)            return ret + 6 - sl;
+                          return ret + 7 - sl;
+}
+libc_hidden_def(strlen)
diff --git a/glibc-2.14.1/sysdeps/riscv/sys/asm.h b/glibc-2.14.1/sysdeps/riscv/sys/asm.h
new file mode 100644
index 0000000..fc30999
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/sys/asm.h
@@ -0,0 +1,69 @@
+/* copyright (c) 1997, 1998, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+/* 
+ * Macros to handle different pointer/register sizes for 32/64-bit code
+ */
+#ifdef __riscv64
+# define PTR .dword
+# define PTRLOG 3
+# define SZREG	8
+# define REG_S sd
+# define REG_L ld
+#else
+# define PTR .word
+# define PTRLOG 2
+# define SZREG	4
+# define REG_S sw
+# define REG_L lw
+#endif
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define	LEAF(symbol)	\
+		.globl	symbol;                         \
+		.align	2;                              \
+		.type	symbol,@function;               \
+symbol:
+
+/*
+ * NESTED - declare nested routine entry point
+ */
+#define	NESTED(symbol, framesize, rpc) LEAF(symbol)
+
+/*
+ * END - mark end of function
+ */
+#ifndef END
+# define END(function)                                   \
+		.size	function,.-function
+#endif
+
+/*
+ * Stack alignment
+ */
+#define ALSZ	15
+#define ALMASK	~15
+
+#endif /* sys/asm.h */
diff --git a/glibc-2.14.1/sysdeps/riscv/tcb-offsets.sym b/glibc-2.14.1/sysdeps/riscv/tcb-offsets.sym
new file mode 100644
index 0000000..e0e71dc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff --git a/glibc-2.14.1/sysdeps/riscv/tst-audit.h b/glibc-2.14.1/sysdeps/riscv/tst-audit.h
new file mode 100644
index 0000000..ac011fc
--- /dev/null
+++ glibc-2.14.1/sysdeps/riscv/tst-audit.h
@@ -0,0 +1,33 @@
+/* Definitions for testing PLT entry/exit auditing.  ARM version.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABI32
+#define pltenter la_mips_n32_gnu_pltenter
+#define pltexit la_mips_n32_gnu_pltexit
+#else
+#define pltenter la_mips_n64_gnu_pltenter
+#define pltexit la_mips_n64_gnu_pltexit
+#endif
+#define La_regs La_mips_64_regs
+#define La_retval La_mips_64_retval
+#define int_retval lrv_v0
diff --git a/glibc-2.14.1/sysdeps/unix/riscv/pipe.S b/glibc-2.14.1/sysdeps/unix/riscv/pipe.S
new file mode 100644
index 0000000..d6c4e4a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/riscv/pipe.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+SYSCALL__ (pipe, 1)
+	/* Plop in the two descriptors.  */
+/*	sw v0, 0(a0)
+	sw v1, 4(a0)
+
+*/
+	/* Go out with a clean status.  */
+	move v0, zero
+	ret
+PSEUDO_END(__pipe)
+
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff --git a/glibc-2.14.1/sysdeps/unix/riscv/rt-sysdep.c b/glibc-2.14.1/sysdeps/unix/riscv/rt-sysdep.c
new file mode 100644
index 0000000..3ff5595
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/riscv/rt-sysdep.c
@@ -0,0 +1 @@
+#include <sysdep.c>
diff --git a/glibc-2.14.1/sysdeps/unix/riscv/sysdep.c b/glibc-2.14.1/sysdeps/unix/riscv/sysdep.c
new file mode 100644
index 0000000..308eced
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/riscv/sysdep.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2002, 2003 
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+long __syscall_error()
+{
+  register long v0 asm("v0");
+
+  /* Referencing errno may call a function, clobbering v0. */
+  long errno_val = -v0;
+
+#if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
+	/* We translate the system's EWOULDBLOCK error into EAGAIN.
+	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
+	   EWOULDBLOCK_sys is the original number.  */
+
+  if (errno_val == EWOULDBLOCK_sys)
+    errno_val = EAGAIN;
+#endif
+
+  errno = errno_val;
+
+  return -1;
+}
diff --git a/glibc-2.14.1/sysdeps/unix/riscv/sysdep.h b/glibc-2.14.1/sysdeps/unix/riscv/sysdep.h
new file mode 100644
index 0000000..910afd5
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/riscv/sysdep.h
@@ -0,0 +1,72 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+#include <sys/asm.h>
+
+#define ENTRY(name) LEAF(name)
+
+#undef END
+#define	END(function)                                   \
+		.size	function,.-function
+
+#define ret	ret
+
+#undef PSEUDO_END
+#define PSEUDO_END(sym) .size sym,.-sym
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  li v0, SYS_ify(syscall_name);				\
+  scall
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym) .size sym,.-sym
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args) \
+  PSEUDO_NOERRNO(name, syscall_name, args)
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym) PSEUDO_END_NOERRNO(sym)
+
+#define ret_ERRVAL ret
+
+#define r0	v0
+#define r1	v1
+#define MOVE(x,y)	move y , x
+
+#define L(label) .L ## label
+
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;							\
+  99: j __syscall_error;					\
+  ENTRY(name)							\
+  li v0, SYS_ify(syscall_name);					\
+  scall;							\
+  bltz v0, 99b;							\
+L(syse1):
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Implies b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Implies
new file mode 100644
index 0000000..72096a4
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Implies
@@ -0,0 +1,2 @@
+# This needs to change to support rv32
+unix/sysv/linux/riscv/rv64
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Makefile b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Makefile
new file mode 100644
index 0000000..4d96756
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Makefile
@@ -0,0 +1,139 @@
+ifeq ($(subdir),signal)
+#sysdep_routines += sigsuspend
+endif
+
+ifeq ($(subdir),misc)
+
+no_syscall_list_h = 1
+
+# A callable macro that expands to a shell command.  Preprocess file $(1)
+# using ABI option $(2) and see which macros it defines.  Print FOO for each
+# macro of the form __NR$(3)_FOO, filtering out ABI-specific __NR macros
+# that have a prefix other than $(3).
+mips_list_syscalls =	$(filter-out -m%,$(CC)) -E -x c $(+includes) \
+			    $(sysincludes) -D_LIBC -dM -m$(2) $(1) | \
+			sed -n 's@^\#define __NR$(3)_\([^ ]*\) .*@\1@p' | \
+			sed -e '/^[ON]32_/d' -e '/^N64_/d' -e '/^64_/d' | \
+			LC_ALL=C sort
+
+# Generate a list of SYS_* macros from the linux __NR macros.
+#
+# Before version 2.6, linux had separate 32-bit and 64-bit MIPS ports,
+# each with its own set of headers.  The ports were merged for 2.6 and
+# this merged port defines the syscalls in a slightly different way.
+# There are therefore three sets of headers that we need to consider:
+#
+#    (1) Headers from the separate 32-bit MIPS port.  They just define
+#	 a single list of __NR macros.
+#
+#    (2) Headers from the separate 64-bit MIPS port.  They unconditionally
+#	 define syscalls for all three ABIs, with o32 syscalls prefixed
+#	 by __NR_O32, n32 syscalls prefixed by __NR_N32 and n64 syscalls
+#	 prefixed by plain __NR.
+#
+#    (3) Headers from the combined port.  They use the _RISCV_SIM macro to
+#	 define the right set of syscalls for the current ABI.  The syscalls
+#	 themselves have no special ABI prefix, but the headers also define:
+#
+#	    __NR_O32_Linux{,_syscalls}
+#	    __NR_N32_Linux{,_syscalls}
+#	    __NR_64_Linux{,_syscalls}
+#
+# In case (1) we just want a simple list of SYS_* macros.  In cases (2)
+# and (3) we want a file that will work for all three ABIs, regardless
+# of which ABI we are currently using.  We also want the file to work
+# if the user later moves from (2) to (3).  Thus the file we create
+# for (2) and (3) has the form:
+#
+#    #if _RISCV_SIM == _ABIN32
+#    # ifdef __NR_N32_open
+#    #  define SYS_n32syscall1 __NR_N32_n32syscall1
+#    #  ...
+#    # else
+#    #  define SYS_n32syscall1 __NR_n32syscall1
+#    #  ...
+#    # endif
+#    #elif _RISCV_SIM == _ABI64
+#    # define SYS_n64syscall1 __NR_n64syscall1
+#    # ...
+#    #else
+#    # ifdef __NR_O32_open
+#    #  define SYS_o32syscall1 __NR_O32_o32syscall1
+#    #  ...
+#    # else
+#    #  define SYS_o32syscall1 __NR_o32syscall1
+#    #  ...
+#    # endif
+#    #endif
+#
+# Here, __NR_N32_open and __NR_O32_open are used to detect case (2)
+# over case (3).  The n64 SYS_* macros can always use the normal
+# ABI-less names.
+$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/mips/sys/syscall.h
+	$(make-target-directory)
+	$(CC) -E -x c $(+includes) $(sysincludes) -D_LIBC $< -MD -MP \
+	      -MF $(@:.h=.d)-t -MT '$(@:.d=.h) $(@:.h=.d)' > /dev/null
+	{ \
+	 echo '/* Generated at libc build time from kernel syscall list.  */';\
+	 echo ''; \
+	 echo '#ifndef _SYSCALL_H'; \
+	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
+	 echo '#endif'; \
+	 echo ''; \
+	 echo '#include <sgidefs.h>'; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).newn32 $(@:.d=.h).new64; \
+	 $(call mips_list_syscalls,$<,n32,_N32) > $(@:.d=.h).newn32; \
+	 if test -s $(@:.d=.h).newn32; then \
+	   if grep open $(@:.d=.h).newn32 > /dev/null; then \
+	     $(call mips_list_syscalls,$<,32,_O32) > $(@:.d=.h).new32; \
+	     $(call mips_list_syscalls,$<,64,) > $(@:.d=.h).new64; \
+	   else \
+	     $(call mips_list_syscalls,$<,32,) > $(@:.d=.h).new32; \
+	     $(call mips_list_syscalls,$<,n32,) > $(@:.d=.h).newn32; \
+	     $(call mips_list_syscalls,$<,64,) > $(@:.d=.h).new64; \
+	   fi; \
+	   echo '#if _RISCV_SIM == _ABIN32'; \
+	   echo '# ifdef __NR_N32_open'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_N32_\1@' < $(@:.d=.h).newn32; \
+	   echo '# else'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_\1@' < $(@:.d=.h).newn32; \
+	   echo '# endif'; \
+	   echo '#elif _RISCV_SIM == _ABI64'; \
+	   sed 's@\(.*\)@# define SYS_\1 __NR_\1@' < $(@:.d=.h).new64; \
+	   echo '#else'; \
+	   echo '# ifdef __NR_O32_open'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_O32_\1@' < $(@:.d=.h).new32; \
+	   echo '# else'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_\1@' < $(@:.d=.h).new32; \
+	   echo '# endif'; \
+	   echo '#endif'; \
+	 else \
+	   $(CC) -E -x c $(+includes) $(sysincludes) -D_LIBC -dM $< | \
+	   sed -n 's@^\#define __NR_\([^ ]*\) .*@\#define SYS_\1 __NR_\1@p' | \
+	   LC_ALL=C sort; \
+	 fi; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).newn32 $(@:.d=.h).new64; \
+	} > $(@:.d=.h).new
+	mv -f $(@:.d=.h).new $(@:.d=.h)
+ifneq (,$(objpfx))
+	sed $(sed-remove-objpfx) $(@:.h=.d)-t > $(@:.h=.d)-t2
+	rm -f $(@:.h=.d)-t
+	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
+else
+	mv -f $(@:.h=.d)-t $(@:.h=.d)
+endif
+endif
+
+ifeq ($(subdir),elf)
+ifeq ($(build-shared),yes)
+# This is needed for DSO loading from static binaries.
+sysdep-dl-routines += dl-static
+sysdep_routines += dl-static
+sysdep-rtld-routines += dl-static
+endif
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_routines += __start_context
+gen-as-const-headers += ucontext_i.sym
+endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Versions b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Versions
new file mode 100644
index 0000000..a56322a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Versions
@@ -0,0 +1,40 @@
+ld {
+  GLIBC_PRIVATE {
+    # used for loading by static libraries
+    _dl_var_init;
+  }
+}
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/Linux configurations.
+
+  GLIBC_2.0 {
+    #errlist-compat	123
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # Needed by gcc:
+    _flush_cache;
+
+    # c*
+    cachectl; cacheflush;
+
+    # s*
+    sysmips;
+  }
+  GLIBC_2.2 {
+    #errlist-compat	1134
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # _*
+    _test_and_set;
+  }
+  GLIBC_2.11 {
+    fallocate64;
+  }
+}
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
new file mode 100644
index 0000000..e903c7e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
@@ -0,0 +1,2 @@
+#define __longjmp ____longjmp_chk
+#include <__longjmp.S>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/__start_context.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/__start_context.S
new file mode 100644
index 0000000..7408289
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/__start_context.S
@@ -0,0 +1,38 @@
+/* Modify saved context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+	.text
+LEAF (__start_context)
+	move	a0, zero
+	beqz	s0, 1f
+
+	/* setcontext (ucp) */
+	move	a0, s0
+	jal	__setcontext
+	move	a0, v0
+
+1:	jal	HIDDEN_JUMPTARGET (exit)
+
+PSEUDO_END (__start_context)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/_test_and_set.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/_test_and_set.c
new file mode 100644
index 0000000..9fd48f7
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/_test_and_set.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the real-function versions of all inline functions
+   defined in sys/tas.h  */
+
+#include <features.h>
+
+#define _EXTERN_INLINE
+#ifndef __USE_EXTERN_INLINES
+# define __USE_EXTERN_INLINES 1
+#endif
+
+#include "sys/tas.h"
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/atomic.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/atomic.h
new file mode 100644
index 0000000..82b9006
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/atomic.h
@@ -0,0 +1,53 @@
+/* Low-level functions for atomic operations. Mips version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_RISCV_BITS_ATOMIC_H
+#define _LINUX_RISCV_BITS_ATOMIC_H 1
+
+#include_next <bits/atomic.h>
+
+#ifndef __riscv_atomic
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+/* The only basic operation needed is compare and exchange.  */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (sysriscv, __err, 4,				      \
+		      RISCV_ATOMIC_CMPXCHG, mem, oldval, newval);	      \
+  })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (sysriscv, __err, 4,				      \
+		      RISCV_ATOMIC_CMPXCHG64, mem, oldval, newval);	      \
+  })
+
+#endif /* __riscv_atomic */
+
+#endif /* bits/atomic.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/endian.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/endian.h
new file mode 100644
index 0000000..6caa0bd
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/endian.h
@@ -0,0 +1,16 @@
+/* The MIPS architecture has selectable endianness.
+   Linux/MIPS exists in two both little and big endian flavours and we
+   want to be able to share the installed headerfiles between both,
+   so we define __BYTE_ORDER based on GCC's predefines.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __RISCVEB__
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# ifdef __RISCVEL__
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h
new file mode 100644
index 0000000..d075e04
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h
@@ -0,0 +1,278 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2006,
+   2007, 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sgidefs.h>
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	00000003
+#define O_RDONLY	00000000
+#define O_WRONLY	00000001
+#define O_RDWR		00000002
+#define O_CREAT		00000100	/* not fcntl */
+#define O_EXCL		00000200	/* not fcntl */
+#define O_NOCTTY	00000400	/* not fcntl */
+#define O_TRUNC		00001000	/* not fcntl */
+#define O_APPEND	00002000
+#define O_NONBLOCK	00004000
+#define O_DSYNC		00010000	/* used to be O_SYNC, see below */
+#define O_DIRECT	00040000	/* direct disk access hint */
+#define O_LARGEFILE	00100000
+#define O_DIRECTORY	00200000	/* must be a directory */
+#define O_NOFOLLOW	00400000	/* don't follow links */
+#define O_NOATIME	01000000
+#define O_CLOEXEC	02000000	/* set close_on_exec */
+#define __O_SYNC	04000000
+#define O_SYNC		(__O_SYNC|O_DSYNC)
+#define O_PATH		010000000
+#define O_NDELAY	O_NONBLOCK
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+
+#define F_GETLK64	33	/* Get record locking info.  */
+#define F_SETLK64	34	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	35	/* Set record locking info (blocking).	*/
+
+#if _RISCV_SIM == _ABI32
+#define F_GETLK		F_GETLK64
+#define F_SETLK		F_SETLK64
+#define F_SETLKW	F_SETLKW64
+#else
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+#endif
+
+#define F_SETOWN	8	/* for sockets. */
+#define F_GETOWN	9	/* for sockets. */
+
+#define F_SETSIG	10	/* for sockets. */
+#define F_GETSIG	11	/* for sockets. */
+#define F_SETOWN_EX	15
+#define F_GETOWN_EX	16
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_SETPIPE_SZ	1031	/* Set pipe page size array.  */
+# define F_GETPIPE_SZ	1032	/* Set pipe page size array.  */
+#endif
+#ifdef __USE_XOPEN2K8
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set.  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#if _RISCV_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       fcntls in o32 and n32, never has this field.  */
+    long int l_sysid;
+#endif
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+#if ! defined __USE_FILE_OFFSET64 && _RISCV_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       flock in o32 and n32, never has this field.  */
+    long int pad[4];
+#endif
+  };
+typedef struct flock flock_t;
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+#ifdef __USE_GNU
+/* Owner types.  */
+enum __pid_type
+  {
+    F_OWNER_TID = 0,		/* Kernel thread.  */
+    F_OWNER_PID,		/* Process.  */
+    F_OWNER_PGRP,		/* Process group.  */
+    F_OWNER_GID = F_OWNER_PGRP	/* Alternative, obsolete name.  */
+  };
+
+/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
+struct f_owner_ex
+  {
+    enum __pid_type type;	/* Owner type of ID.  */
+    __pid_t pid;		/* ID of owner.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+/* Reserve storage for the data of the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fallocate, (int __fd, int __mode, __off64_t __offset,
+				   __off64_t __len),
+		       fallocate64);
+#  else
+#   define fallocate fallocate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
+			__off64_t __len);
+# endif
+
+#endif
+
+__END_DECLS
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/mman.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/mman.h
new file mode 100644
index 0000000..d67fa94
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/mman.h
@@ -0,0 +1,112 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000, 2003, 2004, 2005, 2006, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+# define MAP_RENAME	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+# define MAP_LOCKED	0x2000		/* pages are locked */
+# define MAP_NORESERVE	0x4000		/* don't check for reservations */
+# define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+# define MAP_NONBLOCK	0x10000		/* do not block on IO */
+# define MAP_STACK	0x20000		/* give out an address that is best suited for process/thread stacks */
+# define MAP_HUGETLB	0x40000		/* create a huge page mapping */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	  0	/* No further special treatment.  */
+# define MADV_RANDOM	  1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL  2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	  3	/* Will need these pages.  */
+# define MADV_DONTNEED	  4	/* Don't need these pages.  */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	  10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	  11	/* Do inherit across fork.  */
+# define MADV_MERGEABLE	  12	/* KSM may merge identical pages.  */
+# define MADV_UNMERGEABLE 13	/* KSM may not merge identical pages.  */
+# define MADV_HUGEPAGE	  14	/* Worth backing with hugepages.  */
+# define MADV_NOHUGEPAGE  15	/* Not worth backing with hugepages.  */
+# define MADV_HWPOISON	  100	/* Poison a page for testing.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/msq.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/msq.h
new file mode 100644
index 0000000..422218a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/msq.h
@@ -0,0 +1,83 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+# error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <bits/wordsize.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+#ifdef __USE_GNU
+# define MSG_EXCEPT	020000	/* recv any msg except of specified type */
+#endif
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+/* Structure of record for one message inside the kernel.
+   The type `struct msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  __time_t msg_stime;		/* time of last msgsnd command */
+#if __WORDSIZE == 32
+  unsigned long int __unused1;
+#endif
+  __time_t msg_rtime;		/* time of last msgrcv command */
+#if __WORDSIZE == 32
+  unsigned long int __unused2;
+#endif
+  __time_t msg_ctime;		/* time of last change */
+#if __WORDSIZE == 32
+  unsigned long int __unused3;
+#endif
+  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  unsigned long int __unused4;
+  unsigned long int __unused5;
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* ipcs ctl commands */
+# define MSG_STAT 11
+# define MSG_INFO 12
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgpool;
+    int msgmap;
+    int msgmax;
+    int msgmnb;
+    int msgmni;
+    int msgssz;
+    int msgtql;
+    unsigned short int msgseg;
+  };
+
+#endif /* __USE_MISC */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sem.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sem.h
new file mode 100644
index 0000000..6282de9
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sem.h
@@ -0,0 +1,85 @@
+/* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		11		/* get sempid */
+#define GETVAL		12		/* get semval */
+#define GETALL		13		/* get all semval's */
+#define GETNCNT		14		/* get semncnt */
+#define GETZCNT		15		/* get semzcnt */
+#define SETVAL		16		/* set semval */
+#define SETALL		17		/* set all semval's */
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  __time_t sem_otime;			/* last semop() time */
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  unsigned long int sem_nsems;		/* number of semaphores in set */
+  unsigned long int __unused1;
+  unsigned long int __unused2;
+};
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 18
+# define SEM_INFO 19
+
+struct  seminfo
+{
+  int semmap;
+  int semmni;
+  int semmns;
+  int semmnu;
+  int semmsl;
+  int semopm;
+  int semume;
+  int semusz;
+  int semvmx;
+  int semaem;
+};
+
+#endif /* __USE_MISC */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
new file mode 100644
index 0000000..3e9d7f0
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+struct sigcontext {
+  /* gregs[0] holds the program counter. */
+  unsigned long gregs[32];
+  double fpregs[32];
+  unsigned long fsr;
+};
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/brk.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/brk.c
new file mode 100644
index 0000000..8201409
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/brk.c
@@ -0,0 +1,60 @@
+/* brk system call for Linux/MIPS.
+   Copyright (C) 2000, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+void *__curbrk = 0;
+
+/* Old braindamage in GCC's crtstuff.c requires this symbol in an attempt
+   to work around different old braindamage in the old Linux/x86 ELF
+   dynamic linker.  Sigh.  */
+weak_alias (__curbrk, ___brk_addr)
+
+int
+__brk (void *addr)
+{
+  void *newbrk;
+
+  {
+    register long res asm ("v0");
+    register void*  arg asm ("a0");
+
+    res = SYS_ify (brk);
+    arg = addr;
+
+    asm ("scall"		/* Perform the system call.  */
+	 : "+r" (res)
+	 : "r" (arg)
+	 : __SYSCALL_CLOBBERS);
+
+    newbrk = (void *) res;
+  }
+  __curbrk = newbrk;
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+weak_alias (__brk, brk)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/clone.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/clone.S
new file mode 100644
index 0000000..67b2146
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/clone.S
@@ -0,0 +1,119 @@
+/* Copyright (C) 1996, 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@linux-mips.org>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#ifdef RESET_PID
+#include <tls.h>
+#include "tcb-offsets.h"
+#endif
+
+#define CLONE_VM      0x00000100
+#define CLONE_THREAD  0x00010000
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     void *parent_tidptr, void *tls, void *child_tidptr) */
+
+	.text
+LEAF(__clone)
+
+	/* Sanity check arguments.  */
+	li		v0,EINVAL
+	beqz		a0,L(error)	/* No NULL function pointers.  */
+	beqz		a1,L(error)	/* No NULL stack pointers.  */
+
+	addi		a1,a1,-32		/* Reserve argument save space.  */
+	REG_S		a0,0(a1)	/* Save function pointer.  */
+	REG_S		a3,SZREG(a1)	/* Save argument pointer.  */
+#ifdef RESET_PID
+	REG_S		a2,(SZREG*2)(a1)	/* Save clone flags.  */
+#endif
+
+	move		a0,a2
+
+	/* Shuffle in the last three arguments - arguments 5, 6, and 7 to
+	   this function, but arguments 3, 4, and 5 to the syscall.  */
+	move		a2,a4
+	move		a3,a5
+	move		a4,a6
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	scall
+
+	bltz		v0,L(error)
+	beqz		v0,L(thread_start)
+
+	/* Successful return from the parent */
+	ret
+
+	/* Something bad happened -- no child created */
+L(error):
+	j		__syscall_error
+	END(__clone)
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+ENTRY(__thread_start)
+L(thread_start):
+	/* The stackframe has been created on entry of clone().  */
+
+#ifdef RESET_PID
+	/* Check and see if we need to reset the PID.  */
+	REG_L		a0,(SZREG*2)(sp)
+	li		a1,CLONE_THREAD
+	and		a1,a0,a1
+	beqz		a1,L(restore_pid)
+L(donepid):
+#endif
+
+	/* Restore the arg for user's function.  */
+	REG_L		v0,0(sp)	/* Function pointer.  */
+	REG_L		a0,SZREG(sp)	/* Argument pointer.  */
+
+	/* Call the user's function.  */
+	jalr		v0
+
+	/* Call _exit rather than doing it inline for breakpoint purposes.  */
+	move		a0,v0
+	j		_exit
+
+#ifdef RESET_PID
+L(restore_pid):
+	and		a1,a0,CLONE_VM
+	li		v0,-1
+	bnez		a1,L(gotpid)
+	li		v0,__NR_getpid
+	scall
+L(gotpid):
+	sw		v0,PID_OFFSET(tp)
+	sw		v0,TID_OFFSET(tp)
+	b		L(donepid)
+#endif
+
+	END(__thread_start)
+
+weak_alias (__clone, clone)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure
new file mode 100644
index 0000000..038022f
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure
@@ -0,0 +1,28 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure.in b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure.in
new file mode 100644
index 0000000..87d0cd3
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure.in
@@ -0,0 +1,29 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-cache.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-cache.h
new file mode 100644
index 0000000..8ef4822
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-cache.h
@@ -0,0 +1,45 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldconfig.h>
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6						\
+	  && (! memcmp (path + len - 6, "/lib64", 6)		\
+	      || ! memcmp (path + len - 6, "/lib32", 6)))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "32", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include_next <dl-cache.h>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-static.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-static.c
new file mode 100644
index 0000000..3a99e7e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-static.c
@@ -0,0 +1,92 @@
+/* Variable initialization.  MIPS version.
+   Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+
+#ifdef SHARED
+
+void
+_dl_var_init (void *array[])
+{
+  /* It has to match "variables" below. */
+  enum
+    {
+      DL_PAGESIZE = 0
+    };
+
+  GLRO(dl_pagesize) = *((size_t *) array[DL_PAGESIZE]);
+}
+
+#else
+#include <bits/libc-lock.h>
+
+__libc_lock_define_initialized_recursive (static, _dl_static_lock)
+
+static void *variables[] =
+{
+  &GLRO(dl_pagesize)
+};
+
+static void
+_dl_unprotect_relro (struct link_map *l)
+{
+  ElfW(Addr) start = ((l->l_addr + l->l_relro_addr)
+		      & ~(GLRO(dl_pagesize) - 1));
+  ElfW(Addr) end = ((l->l_addr + l->l_relro_addr + l->l_relro_size)
+		    & ~(GLRO(dl_pagesize) - 1));
+
+  if (start != end)
+    __mprotect ((void *) start, end - start, PROT_READ | PROT_WRITE);
+}
+
+void
+_dl_static_init (struct link_map *l)
+{
+  struct link_map *rtld_map = l;
+  struct r_scope_elem **scope;
+  const ElfW(Sym) *ref = NULL;
+  lookup_t loadbase;
+  void (*f) (void *[]);
+  size_t i;
+
+  __libc_lock_lock_recursive (_dl_static_lock);
+
+  loadbase = _dl_lookup_symbol_x ("_dl_var_init", l, &ref, l->l_local_scope,
+				  NULL, 0, 1, NULL);
+  
+  for (scope = l->l_local_scope; *scope != NULL; scope++)
+    for (i = 0; i < (*scope)->r_nlist; i++)
+      if ((*scope)->r_list[i] == loadbase)
+	{
+	  rtld_map = (*scope)->r_list[i];
+	  break;
+	}
+
+  if (ref != NULL)
+    {
+      f = (void (*) (void *[])) DL_SYMBOL_ADDRESS (loadbase, ref);
+      _dl_unprotect_relro (rtld_map);
+      f (variables);
+      _dl_protect_relro (rtld_map);
+    }
+
+  __libc_lock_unlock_recursive (_dl_static_lock);
+}
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/fcntl.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/fcntl.c
new file mode 100644
index 0000000..ea951bc
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/fcntl.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ftruncate64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ftruncate64.c
new file mode 100644
index 0000000..a46e22f
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ftruncate64.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_ftruncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+extern int __have_no_truncate64;
+#endif
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+__ftruncate64 (int fd, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      int result = INLINE_SYSCALL (ftruncate64, 4, fd, 0,
+				   __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return __ftruncate (fd, (off_t) length);
+#endif
+}
+weak_alias (__ftruncate64, ftruncate64)
+
+#else
+/* Use the generic implementation.  */
+# include <misc/ftruncate64.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getcontext.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getcontext.S
new file mode 100644
index 0000000..c849ddd
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getcontext.S
@@ -0,0 +1,86 @@
+/* Save current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int getcontext (ucontext_t *ucp) */
+
+	.text
+LEAF (__getcontext)
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 3 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, ( 4 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, ( 5 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, ( 6 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, ( 7 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (10 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (11 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(12 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(13 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (14 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (15 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr v1
+
+	fsd	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(10 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(11 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs12,(12 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs13,(13 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs14,(14 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs15,(15 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	li	a3, _NSIG8
+	add     a2, a0, UCONTEXT_SIGMASK
+	move	a1, zero
+	li	a0, SIG_BLOCK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+	bltz	v0, 99f
+
+	ret
+
+99:	j	__syscall_error
+
+PSEUDO_END (__getcontext)
+
+weak_alias (__getcontext, getcontext)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getmsg.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getmsg.c
new file mode 100644
index 0000000..3a1fa08
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getmsg.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getsysstats.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getsysstats.c
new file mode 100644
index 0000000..8053033
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getsysstats.c
@@ -0,0 +1,37 @@
+/* Determine various system internal values, Linux/MIPS version.
+   Copyright (C) 2001, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* We need to define a special parser for /proc/cpuinfo.  */
+#define GET_NPROCS_PARSER(FD, BUFFER, CP, RE, BUFFER_END, RESULT)	  \
+  do									  \
+    {									  \
+      (RESULT) = 0;							  \
+      /* Read all lines and count the lines starting with the string	  \
+	 "cpu model".  We don't have to fear extremely long lines since	  \
+	 the kernel will not generate them.  8192 bytes are really	  \
+	 enough.  */							  \
+      char *l;								  \
+      while ((l = next_line (FD, BUFFER, &CP, &RE, BUFFER_END)) != NULL)  \
+	if (strncmp (l, "cpu model", 9) == 0)				  \
+	  ++(RESULT);							  \
+    }									  \
+  while (0)
+
+#include <sysdeps/unix/sysv/linux/getsysstats.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ipc_priv.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ipc_priv.h
new file mode 100644
index 0000000..67883be
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ipc_priv.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/powerpc/ipc_priv.h>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel-features.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel-features.h
new file mode 100644
index 0000000..151ed7c
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel-features.h
@@ -0,0 +1,41 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 1999-2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABIN32
+# define __ASSUME_FCNTL64		1
+#endif
+
+#define __ASSUME_EVENTFD2		1
+#define __ASSUME_SIGNALFD4		1
+#define __ASSUME_CLONE_THREAD_FLAGS	1
+#define __ASSUME_TGKILL			1
+#define __ASSUME_UTIMES			1
+#define __ASSUME_O_CLOEXEC		1
+#define __ASSUME_SOCK_CLOEXEC		1
+#define __ASSUME_IN_NONBLOCK		1
+#define __ASSUME_PIPE2			1
+#define __ASSUME_EVENTFD2		1
+#define __ASSUME_SIGNALFD4		1
+#define __ASSUME_DUP3			1
+#define __ASSUME_ACCEPT4		1
+
+#include_next <kernel-features.h>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h
new file mode 100644
index 0000000..edf8d45
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h
@@ -0,0 +1,10 @@
+/* Linux kernel RT signal frame. */
+typedef struct kernel_rt_sigframe
+  {
+    uint32_t rs_ass[4];
+    uint32_t rs_code[2];
+    struct siginfo rs_info;
+    struct ucontext rs_uc;
+    uint32_t rs_altcode[8] __attribute__ ((__aligned__ (1 << 7)));
+  }
+kernel_rt_sigframe_t;
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_stat.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_stat.h
new file mode 100644
index 0000000..e898d21
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_stat.h
@@ -0,0 +1,66 @@
+#ifndef __ASM_GENERIC_STAT_H
+#define __ASM_GENERIC_STAT_H
+
+/*
+ * Everybody gets this wrong and has to stick with it for all
+ * eternity. Hopefully, this version gets used by new architectures
+ * so they don't fall into the same traps.
+ *
+ * stat64 is copied from powerpc64, with explicit padding added.
+ * stat is the same structure layout on 64-bit, without the 'long long'
+ * types.
+ *
+ * By convention, 64 bit architectures use the stat interface, while
+ * 32 bit architectures use the stat64 interface. Note that we don't
+ * provide an __old_kernel_stat here, which new architecture should
+ * not have to start with.
+ */
+
+#ifdef _RISCV_SIM == _ABI64
+
+#define STAT_HAVE_NSEC 1
+
+struct kernel_stat {
+	unsigned long	st_dev;		/* Device.  */
+	unsigned long	st_ino;		/* File serial number.  */
+	unsigned int	st_mode;	/* File mode.  */
+	unsigned int	st_nlink;	/* Link count.  */
+	unsigned int	st_uid;		/* User ID of the file's owner.  */
+	unsigned int	st_gid;		/* Group ID of the file's group. */
+	unsigned long	st_rdev;	/* Device number, if device.  */
+	unsigned long	__pad1;
+	long		st_size;	/* Size of file, in bytes.  */
+	int		st_blksize;	/* Optimal block size for I/O.  */
+	int		__pad2;
+	long		st_blocks;	/* Number 512-byte blocks allocated. */
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+	unsigned int	__unused4;
+	unsigned int	__unused5;
+};
+
+/* This matches struct stat64 in glibc2.1. Only used for 32 bit. */
+#else
+struct kernel_stat {
+	unsigned long long st_dev;	/* Device.  */
+	unsigned long long st_ino;	/* File serial number.  */
+	unsigned int	st_mode;	/* File mode.  */
+	unsigned int	st_nlink;	/* Link count.  */
+	unsigned int	st_uid;		/* User ID of the file's owner.  */
+	unsigned int	st_gid;		/* Group ID of the file's group. */
+	unsigned long long st_rdev;	/* Device number, if device.  */
+	unsigned long long __pad1;
+	long long	st_size;	/* Size of file, in bytes.  */
+	int		st_blksize;	/* Optimal block size for I/O.  */
+	int		__pad2;
+	long long	st_blocks;	/* Number 512-byte blocks allocated. */
+    struct timespec st_atim;
+    struct timespec st_mtim;
+    struct timespec st_ctim;
+	unsigned int	__unused4;
+	unsigned int	__unused5;
+};
+#endif
+
+#endif /* __ASM_GENERIC_STAT_H */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ldsodefs.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
new file mode 100644
index 0000000..8d5efec
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
@@ -0,0 +1,33 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects. MIPS.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* We need special support to initialize DSO loaded for statically linked
+   binaries.  */
+extern void _dl_static_init (struct link_map *map);
+#undef DL_STATIC_INIT
+#define DL_STATIC_INIT(map) _dl_static_init (map)
+
+#endif /* ldsodefs.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/libc-abis b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/libc-abis
new file mode 100644
index 0000000..f180a03
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/libc-abis
@@ -0,0 +1,13 @@
+# See the copy of this file in libc for detailed explanations.  This
+# copy needs to include all libc definitions applicable to MIPS; only
+# one copy will be used.
+#
+# Feature Name	Configuration
+# ------------	-------------
+#
+# MIPS PLTs.
+MIPS_PLT	mips*-*-linux*
+#
+# Unique symbol definitions for C++.
+# Architecture independent, all ELF targets (== all targets)
+UNIQUE
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/lockf64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/lockf64.c
new file mode 100644
index 0000000..a88f5a7
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/makecontext.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/makecontext.c
new file mode 100644
index 0000000..a0f0304
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/makecontext.c
@@ -0,0 +1,43 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+#include <sys/ucontext.h>
+#include <stdarg.h>
+#include <assert.h>
+
+void __makecontext (ucontext_t *ucp, void (*func) (void), int argc,
+		    long a0, long a1, long a2, long a3,
+		    long a4, ...)
+{
+  extern void __start_context(void);
+  long i, sp;
+  va_list vl;
+
+  va_start(vl, a4);
+  assert(REG_NARGS == 8);
+
+  /* Set up the stack. */
+  sp = ((long)ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size) & ALMASK;
+
+  /* Put args in a0-a7, then put any remaining args on the stack. */
+  ucp->uc_mcontext.gregs[REG_A0 + 0] = a0;
+  ucp->uc_mcontext.gregs[REG_A0 + 1] = a1;
+  ucp->uc_mcontext.gregs[REG_A0 + 2] = a2;
+  ucp->uc_mcontext.gregs[REG_A0 + 3] = a3;
+  ucp->uc_mcontext.gregs[REG_A0 + 4] = a4;
+  if (__builtin_expect(argc > 5, 0))
+    {
+      long reg_args = argc < REG_NARGS ? argc : REG_NARGS;
+      sp = (sp - (argc - reg_args) * sizeof(long)) & ALMASK;
+      for (i = 5; i < reg_args; i++)
+        ucp->uc_mcontext.gregs[REG_A0 + i] = va_arg(vl, long);
+      for (i = 0; i < argc - reg_args; i++)
+        ((long*)sp)[i] = va_arg(vl, long);
+    }
+
+  ucp->uc_mcontext.gregs[REG_S0] = (long)ucp->uc_link;
+  ucp->uc_mcontext.gregs[REG_SP] = sp;
+  ucp->uc_mcontext.gregs[REG_PC] = (long)func;
+  ucp->uc_mcontext.gregs[REG_RA] = (long)&__start_context;
+}
+
+weak_alias (__makecontext, makecontext)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h
new file mode 100644
index 0000000..c6fae63
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h
@@ -0,0 +1,101 @@
+/* Minimum guaranteed maximum values for system limits.  MIPS Linux version.
+   Copyright (C) 1993-1998,2000,2002,2003,2004,2007,2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* The kernel header pollutes the namespace with the NR_OPEN symbol
+   and defines LINK_MAX although filesystems have different maxima.  A
+   similar thing is true for OPEN_MAX: the limit can be changed at
+   runtime and therefore the macro must not be defined.  Remove this
+   after including the header if necessary.  */
+#ifndef NR_OPEN
+# define __undef_NR_OPEN
+#endif
+#ifndef LINK_MAX
+# define __undef_LINK_MAX
+#endif
+#ifndef OPEN_MAX
+# define __undef_OPEN_MAX
+#endif
+#ifndef ARG_MAX
+# define __undef_ARG_MAX
+#endif
+
+/* The kernel sources contain a file with all the needed information.  */
+#include <linux/limits.h>
+
+/* Have to remove NR_OPEN?  */
+#ifdef __undef_NR_OPEN
+# undef NR_OPEN
+# undef __undef_NR_OPEN
+#endif
+/* Have to remove LINK_MAX?  */
+#ifdef __undef_LINK_MAX
+# undef LINK_MAX
+# undef __undef_LINK_MAX
+#endif
+/* Have to remove OPEN_MAX?  */
+#ifdef __undef_OPEN_MAX
+# undef OPEN_MAX
+# undef __undef_OPEN_MAX
+#endif
+/* Have to remove ARG_MAX?  */
+#ifdef __undef_ARG_MAX
+# undef ARG_MAX
+# undef __undef_ARG_MAX
+#endif
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  At least two pages with 64k pages.  */
+#define PTHREAD_STACK_MIN	131072
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX		32
+
+/* Maximum login name length.  This is arbitrary.  */
+#define LOGIN_NAME_MAX		256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX		64
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX		32768
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h
new file mode 100644
index 0000000..97af317
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h
@@ -0,0 +1,233 @@
+/* Machine-specific pthread type layouts.  MIPS version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+#if _RISCV_SIM == _ABI64
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+#endif
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#if _RISCV_SIM == _ABI64
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#if _RISCV_SIM == _ABI64
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+#endif
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+# if _RISCV_SIM == _ABI64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+#ifdef __riscv_atomic
+typedef volatile int pthread_spinlock_t;
+#else
+typedef pthread_mutex_t pthread_spinlock_t;
+#endif
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h
new file mode 100644
index 0000000..28f8595
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/clone.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/clone.S
new file mode 100644
index 0000000..4106a34
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/clone.S
@@ -0,0 +1,2 @@
+#define RESET_PID
+#include <sysdeps/unix/sysv/linux/riscv/clone.S>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c
new file mode 100644
index 0000000..5b2234f
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c
@@ -0,0 +1,24 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE ((void *) (pd) \
+		   + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/fork.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/fork.c
new file mode 100644
index 0000000..d31889e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/fork.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fork.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h
new file mode 100644
index 0000000..3d1916e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h
@@ -0,0 +1,263 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008,
+   2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif	      
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+									      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+#define lll_trylock(futex) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), 1, 0) != 0;                \
+  })
+
+#define lll_cond_trylock(futex) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), 2, 0) != 0;                \
+  })
+
+#define lll_robust_trylock(futex, id) \
+  ({                                                                          \
+    atomic_compare_and_exchange_val_acq (&(futex), id, 0) != 0;               \
+  })
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+#define lll_lock(futex, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 1, 0);           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      {                                                                       \
+        if (__builtin_constant_p (private) && private == LLL_PRIVATE)         \
+          __lll_lock_wait_private (&(futex));                                 \
+        else                                                                  \
+          __lll_lock_wait (&(futex), private);                                \
+      }                                                                       \
+  })
+
+#define lll_robust_lock(futex, id, private) \
+  ({                                                                          \
+    int result = 0;                                                           \
+    if (atomic_compare_and_exchange_bool_acq (&(futex), id, 0) != 0)          \
+      result = __lll_robust_lock_wait (&(futex), private);                    \
+    result;                                                                   \
+  })
+
+#define lll_cond_lock(futex, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 2, 0);           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      __lll_lock_wait (&(futex), private);                                    \
+  })
+
+#define lll_robust_cond_lock(futex, id, private) \
+  lll_robust_lock (futex, (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+#define lll_timedlock(futex, abstime, private) \
+  ({                                                                          \
+    int val = atomic_compare_and_exchange_val_acq (&(futex), 1, 0);           \
+    int result = 0;                                                           \
+                                                                              \
+    if (__builtin_expect (val != 0, 0))                                       \
+      result = __lll_timedlock_wait (&(futex), abstime, private);             \
+    result;                                                                   \
+  })
+
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  ({                                                                          \
+    int result = 0;                                                           \
+    if (atomic_compare_and_exchange_bool_acq (&(futex), id, 0) != 0)          \
+      result = __lll_robust_timedlock_wait (&(futex), abstime, private);      \
+    result;                                                                   \
+  })
+
+#define lll_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_rel (__futex, 0);			      \
+    if (__builtin_expect (__val > 1, 0))				      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_robust_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_rel (__futex, 0);			      \
+    if (__builtin_expect (__val & FUTEX_WAITERS, 0))			      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {							\
+    __typeof (tid) __tid;				\
+    while ((__tid = (tid)) != 0)			\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S
new file mode 100644
index 0000000..1fdbb26
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Re-negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h
new file mode 100644
index 0000000..029b444
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h
@@ -0,0 +1,156 @@
+/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+#include <sys/asm.h>
+
+/* Gas will put the initial save of $gp into the CIE, because it appears to
+   happen before any instructions.  So we use cfi_same_value instead of
+   cfi_restore.  */
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+#ifdef __PIC__
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+      .align 2;								      \
+  L(pseudo_start):							      \
+      cfi_startproc;							      \
+      cfi_adjust_cfa_offset (STKSPACE);					      \
+  99: RESTORESTK;							      \
+      j __syscall_error;						      \
+  .type __##syscall_name##_nocancel, @function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    SAVESTK;								      \
+    li v0, SYS_ify(syscall_name);					      \
+    scall;								      \
+    bltz v0, SYSCALL_ERROR_LABEL;			       		      \
+    RESTORESTK;								      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  ENTRY (name)								      \
+    SAVESTK;								      \
+    SINGLE_THREAD_P(v1);						      \
+    bnez v1, L(pseudo_cancel);  					      \
+    li v0, SYS_ify(syscall_name);					      \
+    scall;								      \
+    bltz v0, SYSCALL_ERROR_LABEL;			       		      \
+    RESTORESTK;								      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    cfi_adjust_cfa_offset (STKSPACE);					      \
+    REG_S ra, STKOFF_RA(sp);						      \
+    cfi_rel_offset (ra, STKOFF_RA);					      \
+      PUSHARGS_##args;			/* save syscall args */	      	      \
+      CENABLE;								      \
+      REG_S v0, STKOFF_SVMSK(sp);		/* save mask */			      \
+      POPARGS_##args;			/* restore syscall args */	      \
+      li v0, SYS_ify (syscall_name);				      	      \
+      scall;								      \
+      REG_S v0, STKOFF_SC_V0(sp);		/* save syscall result */             \
+      REG_L a0, STKOFF_SVMSK(sp);		/* pass mask as arg1 */		      \
+      CDISABLE;								      \
+      REG_L v0, STKOFF_SC_V0(sp);		/* restore syscall result */          \
+      REG_L ra, STKOFF_RA(sp);		/* restore return address */	      \
+      bltz v0, SYSCALL_ERROR_LABEL;					      \
+      RESTORESTK;								      \
+    L(pseudo_end):
+
+
+  # undef PSEUDO_END
+  # define PSEUDO_END(sym) cfi_endproc; .size sym,.-sym
+
+  #endif
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp); cfi_rel_offset (a0, STKOFF_A0);
+# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp); cfi_rel_offset (a1, STKOFF_A1);
+# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp); cfi_rel_offset (a2, STKOFF_A2);
+# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp); cfi_rel_offset (a3, STKOFF_A3);
+# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp); cfi_rel_offset (a3, STKOFF_A4);
+# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp); cfi_rel_offset (a3, STKOFF_A5);
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
+# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
+# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
+# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
+# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
+# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
+
+/* Save an even number of slots.  Should be 0 if an even number of slots
+   are used below, or SZREG if an odd number are used.  */
+# define STK_PAD	0
+
+/* Place values that we are more likely to use later in this sequence, i.e.
+   closer to the SP at function entry.  If you do that, the are more
+   likely to already be in your d-cache.  */
+# define STKOFF_A5	(STK_PAD)
+# define STKOFF_A4	(STKOFF_A5 + SZREG)
+# define STKOFF_A3	(STKOFF_A4 + SZREG)
+# define STKOFF_A2	(STKOFF_A3 + SZREG)	/* MT and more args.  */
+# define STKOFF_A1	(STKOFF_A2 + SZREG)	/* MT and 2 args.  */
+# define STKOFF_A0	(STKOFF_A1 + SZREG)	/* MT and 1 arg.  */
+# define STKOFF_RA	(STKOFF_A0 + SZREG)	/* Used if MT.  */
+# define STKOFF_SC_V0	(STKOFF_RA + SZREG)	/* Used if MT.  */
+# define STKOFF_SVMSK	(STKOFF_SC_V0 + SZREG)	/* Used if MT.  */
+
+# define STKSPACE	(STKOFF_SVMSK + SZREG)
+# define SAVESTK 	addi sp, sp, -STKSPACE; cfi_adjust_cfa_offset(STKSPACE)
+# define RESTORESTK 	addi sp, sp, STKSPACE; cfi_adjust_cfa_offset(-STKSPACE)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE  jal __pthread_enable_asynccancel
+#  define CDISABLE jal __pthread_disable_asynccancel
+# elif defined IS_IN_librt
+#  define CENABLE  jal __librt_enable_asynccancel
+#  define CDISABLE jal __librt_disable_asynccancel
+# else
+#  define CENABLE  jal __libc_enable_asynccancel
+#  define CDISABLE jal __libc_disable_asynccancel
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  include "tcb-offsets.h"
+#  define SINGLE_THREAD_P(reg)						\
+	lw reg, MULTIPLE_THREADS_OFFSET(tp)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S
new file mode 100644
index 0000000..7fabe8a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S
@@ -0,0 +1,41 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;				/* Negate it.  */		\
+	bnez	t0, 1f;				/* If it was zero... */		\
+	li	t0, 0x80000000;			/* use 0x80000000 instead.  */	\
+1:	sw	t0, PID_OFFSET(tp);		/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;				/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;			 	/* Re-negate it.  */		\
+	li	t1, 0x80000000;			/* Load 0x80000000... */	\
+	bne	t0, t1, 2f;			/* ... compare against it... */	\
+	li	t0, 0;				/* ... use 0 instead.  */	\
+2:	sw	t0, PID_OFFSET(tp);		/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pipe.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pipe.S
new file mode 100644
index 0000000..ed3af63
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pipe.S
@@ -0,0 +1 @@
+#include <sysdeps/unix/riscv/pipe.S>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread.c
new file mode 100644
index 0000000..a6a42d2
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread.c
@@ -0,0 +1,109 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pread64	     /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread (int fd, void *buf, size_t count,
+				off_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+#if _RISCV_SIM != _ABI64
+  assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__libc_pread, pread)
+
+# define __libc_pread(fd, buf, count, offset) \
+     static internal_function __emulate_pread (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread64.c
new file mode 100644
index 0000000..03701b8
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread64.c
@@ -0,0 +1,107 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pread64	     /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
+				  off64_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			      (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
+
+# define __libc_pread64(fd, buf, count, offset) \
+     static internal_function __emulate_pread64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread64.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/profil-counter.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/profil-counter.h
new file mode 100644
index 0000000..8a6a0bc
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/profil-counter.h
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pthread_once.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pthread_once.c
new file mode 100644
index 0000000..2a94504
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pthread_once.c
@@ -0,0 +1 @@
+#include <nptl/sysdeps/unix/sysv/linux/sparc/pthread_once.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/putmsg.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/putmsg.c
new file mode 100644
index 0000000..ebc1680
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/putmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/putmsg.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite.c
new file mode 100644
index 0000000..370262d
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite.c
@@ -0,0 +1,109 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pwrite64	    /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
+				 off_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+#if _RISCV_SIM != _ABI64
+  assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__libc_pwrite, pwrite)
+
+# define __libc_pwrite(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite64.c
new file mode 100644
index 0000000..edcaa23
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite64.c
@@ -0,0 +1,108 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pwrite64	    /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
+				   off64_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+# define __libc_pwrite64(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite64.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/register-dump.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/register-dump.h
new file mode 100644
index 0000000..2b1ec56
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/register-dump.h
@@ -0,0 +1,65 @@
+/* Dump registers.
+   Copyright (C) 2000, 2001, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdio-common/_itoa.h>
+
+static void
+hexvalue (unsigned long int value, char *buf, size_t len)
+{
+  char *cp = _itoa_word (value, buf + len, 16, 0);
+  while (cp > buf)
+    *--cp = '0';
+}
+
+#define REGDUMP_NREGS 32
+#define REGDUMP_PER_LINE (80 / (__WORDSIZE/4 + 4))
+
+static void
+register_dump (int fd, struct ucontext *ctx)
+{
+  int i;
+  char regvalue[__WORDSIZE/4 + 1];
+  char str[82 * ((REGDUMP_NREGS + REGDUMP_PER_LINE - 1) / REGDUMP_PER_LINE)];
+
+  static const char names[REGDUMP_NREGS][4] = {
+    "pc", "ra", "s0", "s1", "s2", "s3", "s4", "s5",
+    "s6", "s7", "s8", "s9", "sA", "sB", "sp", "tp",
+    "v0", "v1", "a0", "a1", "a2", "a3", "a4", "a5",
+    "a6", "a7", "t0", "t1", "t2", "t3", "t4", "gp"
+  };
+
+  str[0] = 0;
+  for (i = 0; i < REGDUMP_NREGS; i++)
+    {
+      strcat (str, names[i]);
+      strcat (str, " ");
+      hexvalue (ctx->uc_mcontext.gregs[i], regvalue, __WORDSIZE/4);
+      strcat (str, regvalue);
+
+      if ((i + 1) % REGDUMP_PER_LINE == 0)
+	strcat (str, "\n");
+    }
+
+  write (fd, str, strlen (str));
+}
+
+#define REGISTER_DUMP register_dump (fd, ctx)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c
new file mode 100644
index 0000000..98a41f9
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Avoid accept4.c trying to use a definition based on the socketcall
+   syscall and internal_accept4.S.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <sys/socket.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <kernel-features.h>
+
+#undef __NR_socketcall
+
+#include <sysdeps/unix/sysv/linux/accept4.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c
new file mode 100644
index 0000000..0f8b313
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstatat.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S
new file mode 100644
index 0000000..30434d7
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S
@@ -0,0 +1,2 @@
+/* MIPS does not have socket.S and the socketcall syscall should
+   generally be avoided, though it exists.  */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S
new file mode 100644
index 0000000..30434d7
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S
@@ -0,0 +1,2 @@
+/* MIPS does not have socket.S and the socketcall syscall should
+   generally be avoided, though it exists.  */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c
new file mode 100644
index 0000000..04c952d
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+/* MIPS kernel only has NR_fadvise64 which acts as NR_fadvise64_64 */
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 7, fd, 0,
+			      __LONG_LONG_PAIR (offset >> 31, offset),
+			      __LONG_LONG_PAIR (len >> 31, len),
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c
new file mode 100644
index 0000000..715d37e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c
@@ -0,0 +1,61 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+/* MIPS kernel only has NR_fadvise64 which acts as NR_fadvise64_64 */
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 7, fd, 0,
+			      __LONG_LONG_PAIR ((long) (offset >> 32),
+						(long) offset),
+			      __LONG_LONG_PAIR ((long) (len >> 32),
+						(long) len),
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise)
+{
+  return __posix_fadvise64_l64 (fd, offset, len, advise);
+}
+
+versioned_symbol (libc, __posix_fadvise64_l64, posix_fadvise64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fadvise64_l32, posix_fadvise64, GLIBC_2_2);
+#else
+strong_alias (__posix_fadvise64_l64, posix_fadvise64);
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
new file mode 100644
index 0000000..b5b967c
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/arm/eabi/readahead.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c
new file mode 100644
index 0000000..ceb88ee
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Avoid recvmmsg.c trying to use a definition based on the socketcall
+   syscall and internal_recvmmsg.S.  */
+
+#include <errno.h>
+#include <sys/socket.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <kernel-features.h>
+
+#undef __NR_socketcall
+
+#include <sysdeps/unix/sysv/linux/recvmmsg.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
new file mode 100644
index 0000000..13a21b0
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
@@ -0,0 +1,47 @@
+/* Selective file content synch'ing.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+
+#ifdef __NR_sync_file_range
+int
+sync_file_range (int fd, __off64_t from, __off64_t to, unsigned int flags)
+{
+  return INLINE_SYSCALL (sync_file_range, 7, fd, 0,
+			 __LONG_LONG_PAIR ((long) (from >> 32), (long) from),
+			 __LONG_LONG_PAIR ((long) (to >> 32), (long) to),
+			 flags);
+}
+#else
+int
+sync_file_range (int fd, __off64_t from, __off64_t to, unsigned int flags)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (sync_file_range)
+
+# include <stub-tag.h>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list
new file mode 100644
index 0000000..f357b5c
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list
@@ -0,0 +1,5 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+prlimit64	EXTRA	prlimit64	i:iipp	prlimit64
+
+fanotify_mark	EXTRA	fanotify_mark	i:iiiiis	fanotify_mark
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/Makefile b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
new file mode 100644
index 0000000..0a37c5b
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
@@ -0,0 +1,9 @@
+ifeq ($(subdir),socket)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c
new file mode 100644
index 0000000..d3b7218
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/fallocate.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c
new file mode 100644
index 0000000..fb2b681
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c
@@ -0,0 +1 @@
+/* fallocate64 is in fallocate.c */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c
new file mode 100644
index 0000000..33918ea
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c
@@ -0,0 +1 @@
+/* glob64 is in glob.c */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
new file mode 100644
index 0000000..43fca83
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
new file mode 100644
index 0000000..2c32732
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
@@ -0,0 +1 @@
+s_^\(RTLDLIST=\)\(.*lib\)\(\|32\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\232\4 \264\4 \2\4"_
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c
new file mode 100644
index 0000000..24013a8
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c
@@ -0,0 +1 @@
+/* lseek() is 64-bit capable already.  */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c
new file mode 100644
index 0000000..0287b83
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c
new file mode 100644
index 0000000..c9f72c4
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c
@@ -0,0 +1 @@
+/* posix_fadvise64 is in posix_fadvise.c */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c
new file mode 100644
index 0000000..b3fe81b
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/posix_fallocate.c>
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c
new file mode 100644
index 0000000..f466f13
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c
@@ -0,0 +1 @@
+/* posix_fallocate64 is in posix_fallocate.c */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c
new file mode 100644
index 0000000..fd9320c
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c
@@ -0,0 +1 @@
+/* Empty since the preadv syscall is equivalent.  */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c
new file mode 100644
index 0000000..8b72a29
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c
@@ -0,0 +1 @@
+/* Empty since the pwritev syscall is equivalent.  */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list
new file mode 100644
index 0000000..ee443cb
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list
@@ -0,0 +1,17 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+lseek		-	lseek		Ci:iii	__libc_lseek	__lseek lseek __llseek llseek __libc_lseek64 __lseek64 lseek64
+prlimit		EXTRA	prlimit64	i:iipp	prlimit		prlimit64
+fanotify_mark	EXTRA	fanotify_mark	i:iiiis	fanotify_mark
+
+# Semaphore and shm system calls.  msgctl, shmctl, and semctl have C
+# wrappers (to set __IPC_64).
+msgget		-	msgget		i:ii	__msgget	msgget
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
+semget		-	semget		i:iii	__semget	semget
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/umount.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/umount.c
new file mode 100644
index 0000000..e7c5690
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/umount.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Huggins-Daines <dhd@debian.org>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Since we don't have an oldumount system call, do what the kernel
+   does down here.  */
+
+extern long int __umount2 (const char *name, int flags);
+
+long int
+__umount (const char *name)
+{
+  return __umount2 (name, 0);
+}
+
+weak_alias (__umount, umount);
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/setcontext.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/setcontext.S
new file mode 100644
index 0000000..07b6f71
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/setcontext.S
@@ -0,0 +1,100 @@
+/* Set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int setcontext (const ucontext_t *ucp) */
+
+	.text
+LEAF (__setcontext)
+
+	mv	t0, a0					/* t0 <- ucp */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	move	a2, zero
+	add     a1, a0, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	v0, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(t0)
+
+	fld	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs10,(10 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs11,(11 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs12,(12 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs13,(13 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs14,(14 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs15,(15 * 8 + MCONTEXT_FPREGS)(t0)
+
+	fssr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	v1, MCONTEXT_PC(t0)
+	REG_L	ra, ( 1 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s0, ( 2 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s1, ( 3 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s2, ( 4 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s3, ( 5 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s4, ( 6 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s5, ( 7 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s6, ( 8 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s7, ( 9 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s8, (10 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s9, (11 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s10,(12 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s11,(13 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	sp, (14 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	tp, (15 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a0, (18 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a1, (19 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a2, (20 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a3, (21 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a4, (22 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a5, (23 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a6, (24 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a7, (25 * SZREG + MCONTEXT_GREGS)(t0)
+
+	jr	v1
+
+99:	j	__syscall_error
+
+PSEUDO_END (__setcontext)
+
+weak_alias (__setcontext, setcontext)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
new file mode 100644
index 0000000..ea01f8e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ucontext.h>
+
+#define SIGCONTEXT siginfo_t *_si, struct ucontext *
+#define SIGCONTEXT_EXTRA_ARGS _si,
+#define GET_PC(ctx)	((void *) ctx->uc_mcontext.gregs[REG_PC])
+#define GET_FRAME(ctx)	((void *) ctx->uc_mcontext.gregs[REG_S0])
+#define GET_STACK(ctx)	((void *) ctx->uc_mcontext.gregs[REG_SP])
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/socket.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/socket.S
new file mode 100644
index 0000000..1f66cd4
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/socket.S
@@ -0,0 +1,91 @@
+/* Copyright (C) 1997, 1998, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#include <socketcall.h>
+
+#define P(a, b) P2(a, b)
+#define P2(a, b) a##b
+
+#ifndef NARGS
+#ifdef socket
+#error NARGS not defined
+#endif
+#define NARGS 3
+#endif
+
+	.text
+/* The socket-oriented system calls are handled unusually in Linux.
+   They are all gated through the single `socketcall' system call number.
+   `socketcall' takes two arguments: the first is the subcode, specifying
+   which socket function is being called; and the second is a pointer to
+   the arguments to the specific function.
+
+   The .S files for the other calls just #define socket and #include this.  */
+
+#ifndef __socket
+# ifndef NO_WEAK_ALIAS
+#  define __socket P(__,socket)
+# else
+#  define __socket socket
+# endif
+#endif
+
+LEAF (__socket)
+
+	addi  sp, sp, -SZREG*NARGS
+
+	REG_S a0, 0*SZREG(sp)
+	REG_S a1, 1*SZREG(sp)
+#if NARGS > 2
+	REG_S a2, 2*SZREG(sp)
+#if NARGS > 3
+	REG_S a3, 3*SZREG(sp)
+#if NARGS > 4
+	REG_S a4, 4*SZREG(sp)
+#if NARGS > 5
+	REG_S a5, 5*SZREG(sp)
+#endif
+#endif
+#endif
+#endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P(a0)
+	bnez  a0, 1f
+#endif
+	li    a0, P(SOCKOP_,socket)   /* arg 1: socket subfunction */
+	move  a1, sp			/* arg 2: parameter block */
+	li    v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	addi  sp, sp, SZREG*NARGS
+	bltz	v0, 99f
+
+#if defined NEED_CANCELLATION && defined CENABLE
+1:sbreak
+#endif
+
+99: 	j	__syscall_error
+
+END (__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/swapcontext.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/swapcontext.S
new file mode 100644
index 0000000..76ec343
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/swapcontext.S
@@ -0,0 +1,138 @@
+/* Save and set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int swapcontext (ucontext_t *oucp, const ucontext_t *ucp) */
+
+LEAF (__swapcontext)
+	mv	t0, a1					/* t0 <- ucp */
+
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 3 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, ( 4 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, ( 5 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, ( 6 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, ( 7 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (10 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (11 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(12 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(13 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (14 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (15 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr v1
+
+	fsd	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(10 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(11 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs12,(12 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs13,(13 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs14,(14 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs15,(15 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	add	a2, a0, UCONTEXT_SIGMASK
+	add     a1, a1, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	v0, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(t0)
+
+	fld	fs0, ( 0 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs1, ( 1 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs2, ( 2 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs3, ( 3 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs4, ( 4 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs5, ( 5 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs6, ( 6 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs7, ( 7 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs8, ( 8 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs9, ( 9 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs10,(10 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs11,(11 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs12,(12 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs13,(13 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs14,(14 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs15,(15 * 8 + MCONTEXT_FPREGS)(t0)
+
+	fssr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	v1, MCONTEXT_PC(t0)
+	REG_L	ra, ( 1 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s0, ( 2 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s1, ( 3 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s2, ( 4 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s3, ( 5 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s4, ( 6 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s5, ( 7 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s6, ( 8 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s7, ( 9 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s8, (10 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s9, (11 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s10,(12 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s11,(13 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	sp, (14 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	tp, (15 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a0, (18 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a1, (19 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a2, (20 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a3, (21 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a4, (22 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a5, (23 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a6, (24 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a7, (25 * SZREG + MCONTEXT_GREGS)(t0)
+
+	jr	v1
+
+99:	j	__syscall_error
+
+PSEUDO_END (__swapcontext)
+
+weak_alias (__swapcontext, swapcontext)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h
new file mode 100644
index 0000000..3d9f914
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_CACHECTL_H
+#define _SYS_CACHECTL_H 1
+
+#include <features.h>
+
+/*
+ * Get the kernel definition for the op bits.
+ */
+#include <asm/cachectl.h>
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+extern int cachectl (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#endif
+extern int __cachectl (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#ifdef __USE_MISC
+extern int cacheflush (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#endif
+extern int _flush_cache (char *__addr, __const int __nbytes, __const int __op) __THROW;
+
+__END_DECLS
+
+#endif /* sys/cachectl.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/epoll.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/epoll.h
new file mode 100644
index 0000000..6d2ec8e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/epoll.h
@@ -0,0 +1,144 @@
+/* Copyright (C) 2002-2006, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H	1
+
+#include <stdint.h>
+#include <sys/types.h>
+
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
+
+/* Flags to be passed to epoll_create1.  */
+enum
+  {
+    EPOLL_CLOEXEC = 02000000,
+#define EPOLL_CLOEXEC EPOLL_CLOEXEC
+    EPOLL_NONBLOCK = 0200
+#define EPOLL_NONBLOCK EPOLL_NONBLOCK
+  };
+
+
+enum EPOLL_EVENTS
+  {
+    EPOLLIN = 0x001,
+#define EPOLLIN EPOLLIN
+    EPOLLPRI = 0x002,
+#define EPOLLPRI EPOLLPRI
+    EPOLLOUT = 0x004,
+#define EPOLLOUT EPOLLOUT
+    EPOLLRDNORM = 0x040,
+#define EPOLLRDNORM EPOLLRDNORM
+    EPOLLRDBAND = 0x080,
+#define EPOLLRDBAND EPOLLRDBAND
+    EPOLLWRNORM = 0x100,
+#define EPOLLWRNORM EPOLLWRNORM
+    EPOLLWRBAND = 0x200,
+#define EPOLLWRBAND EPOLLWRBAND
+    EPOLLMSG = 0x400,
+#define EPOLLMSG EPOLLMSG
+    EPOLLERR = 0x008,
+#define EPOLLERR EPOLLERR
+    EPOLLHUP = 0x010,
+#define EPOLLHUP EPOLLHUP
+    EPOLLRDHUP = 0x2000,
+#define EPOLLRDHUP EPOLLRDHUP
+    EPOLLONESHOT = (1 << 30),
+#define EPOLLONESHOT EPOLLONESHOT
+    EPOLLET = (1 << 31)
+#define EPOLLET EPOLLET
+  };
+
+
+/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */
+#define EPOLL_CTL_ADD 1	/* Add a file descriptor to the interface.  */
+#define EPOLL_CTL_DEL 2	/* Remove a file descriptor from the interface.  */
+#define EPOLL_CTL_MOD 3	/* Change file descriptor epoll_event structure.  */
+
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+};
+
+
+__BEGIN_DECLS
+
+/* Creates an epoll instance.  Returns an fd for the new instance.
+   The "size" parameter is a hint specifying the number of file
+   descriptors to be associated with the new instance.  The fd
+   returned by epoll_create() should be closed with close().  */
+extern int epoll_create (int __size) __THROW;
+
+/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE
+   parameter has been dropped.  */
+extern int epoll_create1 (int __flags) __THROW;
+
+
+/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
+   -1 in case of error ( the "errno" variable will contain the
+   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
+   constants defined above. The "fd" parameter is the target of the
+   operation. The "event" parameter describes which events the caller
+   is interested in and any associated user data.  */
+extern int epoll_ctl (int __epfd, int __op, int __fd,
+		      struct epoll_event *__event) __THROW;
+
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_wait (int __epfd, struct epoll_event *__events,
+		       int __maxevents, int __timeout);
+
+
+/* Same as epoll_wait, but the thread's signal mask is temporarily
+   and atomically replaced with the one provided as parameter.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_pwait (int __epfd, struct epoll_event *__events,
+			int __maxevents, int __timeout,
+			__const __sigset_t *__ss);
+
+__END_DECLS
+
+#endif /* sys/epoll.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h
new file mode 100644
index 0000000..b30d09a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h
@@ -0,0 +1,54 @@
+/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EVENTFD_H
+#define	_SYS_EVENTFD_H	1
+
+#include <stdint.h>
+
+
+/* Type for event counter.  */
+typedef uint64_t eventfd_t;
+
+/* Flags for signalfd.  */
+enum
+  {
+    EFD_SEMAPHORE = 1,
+#define EFD_SEMAPHORE EFD_SEMAPHORE
+    EFD_CLOEXEC = 02000000,
+#define EFD_CLOEXEC EFD_CLOEXEC
+    EFD_NONBLOCK = 0200
+#define EFD_NONBLOCK EFD_NONBLOCK
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for generic event channel.  Set initial
+   value to COUNT.  */
+extern int eventfd (int __count, int __flags) __THROW;
+
+/* Read event counter and possibly wait for events.  */
+extern int eventfd_read (int __fd, eventfd_t *__value);
+
+/* Increment event counter.  */
+extern int eventfd_write (int __fd, eventfd_t __value);
+
+__END_DECLS
+
+#endif /* sys/eventfd.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/inotify.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/inotify.h
new file mode 100644
index 0000000..d1d0509
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/inotify.h
@@ -0,0 +1,107 @@
+/* Copyright (C) 2005, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_INOTIFY_H
+#define	_SYS_INOTIFY_H	1
+
+#include <stdint.h>
+
+
+/* Flags for the parameter of inotify_init1.  */
+enum
+  {
+    IN_CLOEXEC = 02000000,
+#define IN_CLOEXEC IN_CLOEXEC
+    IN_NONBLOCK = 0200
+#define IN_NONBLOCK IN_NONBLOCK
+  };
+
+
+/* Structure describing an inotify event.  */
+struct inotify_event
+{
+  int wd;		/* Watch descriptor.  */
+  uint32_t mask;	/* Watch mask.  */
+  uint32_t cookie;	/* Cookie to synchronize two events.  */
+  uint32_t len;		/* Length (including NULs) of name.  */
+  char name __flexarr;	/* Name.  */
+};
+
+
+/* Supported events suitable for MASK parameter of INOTIFY_ADD_WATCH.  */
+#define IN_ACCESS	 0x00000001	/* File was accessed.  */
+#define IN_MODIFY	 0x00000002	/* File was modified.  */
+#define IN_ATTRIB	 0x00000004	/* Metadata changed.  */
+#define IN_CLOSE_WRITE	 0x00000008	/* Writtable file was closed.  */
+#define IN_CLOSE_NOWRITE 0x00000010	/* Unwrittable file closed.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* Close.  */
+#define IN_OPEN		 0x00000020	/* File was opened.  */
+#define IN_MOVED_FROM	 0x00000040	/* File was moved from X.  */
+#define IN_MOVED_TO      0x00000080	/* File was moved to Y.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO) /* Moves.  */
+#define IN_CREATE	 0x00000100	/* Subfile was created.  */
+#define IN_DELETE	 0x00000200	/* Subfile was deleted.  */
+#define IN_DELETE_SELF	 0x00000400	/* Self was deleted.  */
+#define IN_MOVE_SELF	 0x00000800	/* Self was moved.  */
+
+/* Events sent by the kernel.  */
+#define IN_UNMOUNT	 0x00002000	/* Backing fs was unmounted.  */
+#define IN_Q_OVERFLOW	 0x00004000	/* Event queued overflowed.  */
+#define IN_IGNORED	 0x00008000	/* File was ignored.  */
+
+/* Helper events.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)	/* Close.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO)		/* Moves.  */
+
+/* Special flags.  */
+#define IN_ONLYDIR	 0x01000000	/* Only watch the path if it is a
+					   directory.  */
+#define IN_DONT_FOLLOW	 0x02000000	/* Do not follow a sym link.  */
+#define IN_EXCL_UNLINK	 0x04000000	/* Exclude events on unlinked
+					   objects.  */
+#define IN_MASK_ADD	 0x20000000	/* Add to the mask of an already
+					   existing watch.  */
+#define IN_ISDIR	 0x40000000	/* Event occurred against dir.  */
+#define IN_ONESHOT	 0x80000000	/* Only send event once.  */
+
+/* All events which a program can wait on.  */
+#define IN_ALL_EVENTS	 (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE  \
+			  | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM	      \
+			  | IN_MOVED_TO | IN_CREATE | IN_DELETE		      \
+			  | IN_DELETE_SELF | IN_MOVE_SELF)
+
+
+__BEGIN_DECLS
+
+/* Create and initialize inotify instance.  */
+extern int inotify_init (void) __THROW;
+
+/* Create and initialize inotify instance.  */
+extern int inotify_init1 (int __flags) __THROW;
+
+/* Add watch of object NAME to inotify instance FD.  Notify about
+   events specified by MASK.  */
+extern int inotify_add_watch (int __fd, const char *__name, uint32_t __mask)
+  __THROW;
+
+/* Remove the watch specified by WD from the inotify instance FD.  */
+extern int inotify_rm_watch (int __fd, int __wd) __THROW;
+
+__END_DECLS
+
+#endif /* sys/inotify.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/procfs.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
new file mode 100644
index 0000000..ce11419
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <sgidefs.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sgidefs.h>
+
+/* ELF register definitions */
+#define ELF_NGREG	45
+#define ELF_NFPREG	33
+
+#if _RISCV_SIM == _ABIN32
+__extension__ typedef unsigned long long elf_greg_t;
+#else
+typedef unsigned long elf_greg_t;
+#endif
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
+__BEGIN_DECLS
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_sigpend;
+    __extension__ unsigned long long int pr_sighold;
+#else
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+#endif
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_flag;
+#else
+    unsigned long int pr_flag;		/* Flags.  */
+#endif
+    long pr_uid;
+    long pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore habe only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h
new file mode 100644
index 0000000..08923c0
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h
@@ -0,0 +1,66 @@
+/* Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_SIGNALFD_H
+#define	_SYS_SIGNALFD_H	1
+
+#define __need_sigset_t
+#include <signal.h>
+#include <stdint.h>
+
+
+struct signalfd_siginfo
+{
+  uint32_t ssi_signo;
+  int32_t ssi_errno;
+  int32_t ssi_code;
+  uint32_t ssi_pid;
+  uint32_t ssi_uid;
+  int32_t ssi_fd;
+  uint32_t ssi_tid;
+  uint32_t ssi_band;
+  uint32_t ssi_overrun;
+  uint32_t ssi_trapno;
+  int32_t ssi_status;
+  int32_t ssi_int;
+  uint64_t ssi_ptr;
+  uint64_t ssi_utime;
+  uint64_t ssi_stime;
+  uint64_t ssi_addr;
+  uint8_t __pad[48];
+};
+
+/* Flags for signalfd.  */
+enum
+  {
+    SFD_CLOEXEC = 02000000,
+#define SFD_CLOEXEC SFD_CLOEXEC
+    SFD_NONBLOCK = 0200
+#define SFD_NONBLOCK SFD_NONBLOCK
+  };
+
+__BEGIN_DECLS
+
+/* Request notification for delivery of signals in MASK to be
+   performed using descriptor FD.*/
+extern int signalfd (int __fd, const sigset_t *__mask, int __flags)
+  __THROW __nonnull ((2));
+
+__END_DECLS
+
+#endif /* sys/signalfd.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/syscall.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/syscall.h
new file mode 100644
index 0000000..57d646e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/syscall.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/* This file should list the numbers of the system the system knows.
+   But instead of duplicating this we use the information available
+   from the kernel sources.  */
+#include <asm/unistd.h>
+
+#ifndef _LIBC
+/* The Linux kernel header file defines macros `__NR_<name>', but some
+   programs expect the traditional form `SYS_<name>'.  So in building libc
+   we scan the kernel's list and produce <bits/syscall.h> with macros for
+   all the `SYS_' names.  */
+# include <bits/syscall.h>
+#endif
+
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h
new file mode 100644
index 0000000..aefc52e
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1995, 1997, 2000, 2001, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMIPS_H
+#define _SYS_SYSMIPS_H 1
+
+#include <features.h>
+
+/*
+ * Commands for the sysmips(2) call
+ *
+ * sysmips(2) is deprecated - though some existing software uses it.
+ * We only support the following commands.  Sysmips exists for compatibility
+ * purposes only so new software should avoid it.
+ */
+#define SETNAME                   1	/* set hostname                  */
+#define FLUSH_CACHE		   3	/* writeback and invalidate caches */
+#define MIPS_FIXADE               7	/* control address error fixing  */
+#define MIPS_RDNVRAM              10	/* read NVRAM			 */
+#define MIPS_ATOMIC_SET		2001	/* atomically set variable       */
+
+__BEGIN_DECLS
+
+extern int sysmips (__const int __cmd, ...) __THROW;
+
+__END_DECLS
+
+#endif /* sys/sysmips.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/tas.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/tas.h
new file mode 100644
index 0000000..8f27db2
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/tas.h
@@ -0,0 +1,51 @@
+/* Copyright (C) 2000, 2002, 2003, 2004, 2007, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_TAS_H
+#define _SYS_TAS_H 1
+
+#include <features.h>
+#include <sgidefs.h>
+
+__BEGIN_DECLS
+
+extern int _test_and_set (int *__p, int __v) __THROW;
+
+#ifdef __USE_EXTERN_INLINES
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+
+_EXTERN_INLINE int
+__NTH (_test_and_set (int *__p, int __v))
+{
+  int __r = __sync_lock_test_and_set(__p, __v);
+
+  __sync_synchronize();
+
+  return __r;
+}
+
+#endif /* __USE_EXTERN_INLINES */
+
+__END_DECLS
+
+#endif /* sys/tas.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h
new file mode 100644
index 0000000..ebd37ff
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h
@@ -0,0 +1,60 @@
+/* Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_TIMERFD_H
+#define	_SYS_TIMERFD_H	1
+
+#include <time.h>
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_create'.  */
+enum
+  {
+    TFD_CLOEXEC = 02000000,
+#define TFD_CLOEXEC TFD_CLOEXEC
+    TFD_NONBLOCK = 0200
+#define TFD_NONBLOCK TFD_NONBLOCK
+  };
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_settime'.  */
+enum
+  {
+    TFD_TIMER_ABSTIME = 1 << 0
+#define TFD_TIMER_ABSTIME TFD_TIMER_ABSTIME
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for new interval timer source.  */
+extern int timerfd_create (clockid_t __clock_id, int __flags) __THROW;
+
+/* Set next expiration time of interval timer source UFD to UTMR.  If
+   FLAGS has the TFD_TIMER_ABSTIME flag set the timeout value is
+   absolute.  Optionally return the old expiration time in OTMR.  */
+extern int timerfd_settime (int __ufd, int __flags,
+			    __const struct itimerspec *__utmr,
+			    struct itimerspec *__otmr) __THROW;
+
+/* Return the next expiration time of UFD.  */
+extern int timerfd_gettime (int __ufd, struct itimerspec *__otmr) __THROW;
+
+__END_DECLS
+
+#endif /* sys/timerfd.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
new file mode 100644
index 0000000..b81ce52
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
@@ -0,0 +1,66 @@
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004, 2006, 2009 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Don't rely on this, the interface is currently messed up and may need to
+   be broken to be fixed.  */
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* Type for general register.  Even in o32 we assume 64-bit registers,
+   like the kernel.  */
+__extension__ typedef unsigned long long int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	32
+#define NFPREG	32
+
+#define REG_PC 0
+#define REG_RA 1
+#define REG_S0 2
+#define REG_A0 18
+#define REG_NARGS 8
+#define REG_SP 14
+#define REG_TP 15
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Container for all FPU registers.  */
+typedef double fpregset_t[NFPREG];
+
+/* Context to describe whole processor state.  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/user.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/user.h
new file mode 100644
index 0000000..5522050
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/user.h
@@ -0,0 +1,219 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+#include <sgidefs.h>
+
+/* The whole purpose of this file is for GDB and GDB only.  Don't read
+   too much into it.  Don't use it for anything other than GDB unless
+   you know what you are doing.  */
+
+/* #include <asm/reg.h> */
+/* Instead of including the kernel header, that will vary depending on
+   whether the 32- or the 64-bit kernel is installed, we paste its
+   contents here.  Note that the fact that the file is inline here,
+   instead of included separately, doesn't change in any way the
+   licensing status of a program that includes user.h.  Since this is
+   for gdb alone, and gdb is GPLed, no surprises here.  */
+#if _RISCV_SIM == _ABIO32
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 by Ralf Baechle
+ */
+#ifndef __ASM_MIPS_REG_H
+#define __ASM_MIPS_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			6
+#define EF_REG1			7
+#define EF_REG2			8
+#define EF_REG3			9
+#define EF_REG4			10
+#define EF_REG5			11
+#define EF_REG6			12
+#define EF_REG7			13
+#define EF_REG8			14
+#define EF_REG9			15
+#define EF_REG10		16
+#define EF_REG11		17
+#define EF_REG12		18
+#define EF_REG13		19
+#define EF_REG14		20
+#define EF_REG15		21
+#define EF_REG16		22
+#define EF_REG17		23
+#define EF_REG18		24
+#define EF_REG19		25
+#define EF_REG20		26
+#define EF_REG21		27
+#define EF_REG22		28
+#define EF_REG23		29
+#define EF_REG24		30
+#define EF_REG25		31
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		34
+#define EF_REG29		35
+#define EF_REG30		36
+#define EF_REG31		37
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			38
+#define EF_HI			39
+
+#define EF_CP0_EPC		40
+#define EF_CP0_BADVADDR		41
+#define EF_CP0_STATUS		42
+#define EF_CP0_CAUSE		43
+
+#define EF_SIZE			180	/* size in bytes */
+
+#endif /* __ASM_MIPS_REG_H */
+
+#else /* _RISCV_SIM != _ABIO32 */
+
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 Ralf Baechle
+ * Copyright (C) 1995, 1999 Silicon Graphics
+ */
+#ifndef _ASM_REG_H
+#define _ASM_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			 0
+#define EF_REG1			 1
+#define EF_REG2			 2
+#define EF_REG3			 3
+#define EF_REG4			 4
+#define EF_REG5			 5
+#define EF_REG6			 6
+#define EF_REG7			 7
+#define EF_REG8			 8
+#define EF_REG9			 9
+#define EF_REG10		10
+#define EF_REG11		11
+#define EF_REG12		12
+#define EF_REG13		13
+#define EF_REG14		14
+#define EF_REG15		15
+#define EF_REG16		16
+#define EF_REG17		17
+#define EF_REG18		18
+#define EF_REG19		19
+#define EF_REG20		20
+#define EF_REG21		21
+#define EF_REG22		22
+#define EF_REG23		23
+#define EF_REG24		24
+#define EF_REG25		25
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		28
+#define EF_REG29		29
+#define EF_REG30		30
+#define EF_REG31		31
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			32
+#define EF_HI			33
+
+#define EF_CP0_EPC		34
+#define EF_CP0_BADVADDR		35
+#define EF_CP0_STATUS		36
+#define EF_CP0_CAUSE		37
+
+#define EF_SIZE			304	/* size in bytes */
+
+#endif /* _ASM_REG_H */
+
+#endif /* _RISCV_SIM != _ABIO32 */
+
+#if _RISCV_SIM == _ABIO32
+
+struct user
+{
+  unsigned long	regs[EF_SIZE/4+64];	/* integer and fp regs */
+  size_t	u_tsize;		/* text size (pages) */
+  size_t	u_dsize;		/* data size (pages) */
+  size_t	u_ssize;		/* stack size (pages) */
+  unsigned long	start_code;		/* text starting address */
+  unsigned long	start_data;		/* data starting address */
+  unsigned long	start_stack;		/* stack starting address */
+  long int	signal;			/* signal causing core dump */
+  void*		u_ar0;			/* help gdb find registers */
+  unsigned long	magic;			/* identifies a core file */
+  char		u_comm[32];		/* user command name */
+};
+
+#else
+
+struct user {
+  __extension__ unsigned long	regs[EF_SIZE/8+64]; /* integer and fp regs */
+  __extension__ unsigned long	u_tsize;	/* text size (pages) */
+  __extension__ unsigned long	u_dsize;	/* data size (pages) */
+  __extension__ unsigned long	u_ssize;	/* stack size (pages) */
+  __extension__ unsigned long long start_code;	/* text starting address */
+  __extension__ unsigned long long start_data;	/* data starting address */
+  __extension__ unsigned long long start_stack;	/* stack starting address */
+  __extension__ long long	signal;		/* signal causing core dump */
+  __extension__ unsigned long long u_ar0;	/* help gdb find registers */
+  __extension__ unsigned long long magic;	/* identifies a core file */
+  char		u_comm[32];		/* user command name */
+};
+
+#endif
+
+#define PAGE_SHIFT		12
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif	/* _SYS_USER_H */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscall.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscall.c
new file mode 100644
index 0000000..0dcf09f
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscall.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+long syscall (long syscall_number, long arg1, long arg2, long arg3,
+	      long arg4, long arg5, long arg6, long arg7)
+{
+  long ret, err; 
+
+  ret = INTERNAL_SYSCALL_NCS(syscall_number, err, 7, arg1, arg2, arg3, arg4,
+			     arg5, arg6, arg7);
+
+  if (INTERNAL_SYSCALL_ERROR_P(ret, err))
+  {
+    __set_errno(INTERNAL_SYSCALL_ERRNO(ret, err));
+    ret = -1;
+  }
+
+  return ret;
+}
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscalls.list b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscalls.list
new file mode 100644
index 0000000..518f2a2
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscalls.list
@@ -0,0 +1,31 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+#
+# Calls for compatibility with existing MIPS OS implementations and
+# compilers.
+#
+cachectl	-	cachectl	i:pii	__cachectl	cachectl
+cacheflush	-	cacheflush	i:pii	_flush_cache	cacheflush
+sysmips		-	sysmips		i:iiii	__sysmips	sysmips
+
+#
+# Socket functions; Linux/MIPS doesn't use the socketcall(2) wrapper;
+# it's provided for compatibility, though.
+#
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
+bind		-	bind		i:ipi	__bind		bind
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
+listen		-	listen		i:ii	__listen	listen
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN __libc_recvfrom __recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn __libc_sendto	__sendto sendto
+setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sysdep.h b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sysdep.h
new file mode 100644
index 0000000..782cb94
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sysdep.h
@@ -0,0 +1,247 @@
+/* Copyright (C) 2000, 2002, 2003, 2004, 2005, 2006, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_SYSDEP_H
+#define _LINUX_MIPS_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/riscv/sysdep.h>
+
+#include <tls.h>
+
+/* In order to get __set_errno() definition in INLINE_SYSCALL.  */
+#ifndef __ASSEMBLER__
+#include <errno.h>
+#endif
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+
+#else   /* ! __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);		\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )			\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));	\
+	 result_var = -1L;						\
+       }								\
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (val) < 0)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (-val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (SYS_ify (name), err, args)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (number, err, args)
+
+#define internal_syscall0(number, err, dummy...)			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0)							\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(number, err, arg0)				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0)						\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(number, err, arg0, arg1)	    		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1)				\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(number, err, arg0, arg1, arg2)      		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2)			\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(number, err, arg0, arg1, arg2, arg3)	  \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(number, err, arg0, arg1, arg2, arg3, arg4)    \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(number, err, arg0, arg1, arg2, arg3, arg4, arg5) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall7(number, err, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	register long __a6 asm("a6") = (long) (arg6);   		\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__v0)							\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5), "r"(__a6)     \
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "v1", "memory"
+#endif /* __ASSEMBLER__ */
+
+/* Pointer mangling is not supported.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#endif /* linux/mips/sysdep.h */
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/truncate64.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/truncate64.c
new file mode 100644
index 0000000..01cc148
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/truncate64.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997,1998,1999,2000,2002,2003,2005,2006
+   	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <endian.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_truncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+int __have_no_truncate64;
+#endif
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+truncate64 (const char *path, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      int result = INLINE_SYSCALL (truncate64, 4, CHECK_STRING (path), 0,
+				   __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return truncate (path, (off_t) length);
+#endif
+}
+
+#else
+/* Use the generic implementation.  */
+# include <misc/truncate64.c>
+#endif
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
new file mode 100644
index 0000000..8eddf9a
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
@@ -0,0 +1,42 @@
+#include <inttypes.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sys/ucontext.h>
+
+#include <kernel_rt_sigframe.h>
+
+-- Constants used by the rt_sigprocmask call.
+
+SIG_BLOCK
+SIG_SETMASK
+
+_NSIG8				(_NSIG / 8)
+
+-- Offsets of the fields in the kernel rt_sigframe_t structure.
+#define rt_sigframe(member)	offsetof (kernel_rt_sigframe_t, member)
+
+RT_SIGFRAME_UCONTEXT		rt_sigframe (rs_uc)
+
+RT_SIGFRAME_SIZE		sizeof (kernel_rt_sigframe_t)
+
+-- Offsets of the fields in the ucontext_t structure.
+#define ucontext(member)	offsetof (ucontext_t, member)
+#define stack(member)		ucontext (uc_stack.member)
+#define mcontext(member)	ucontext (uc_mcontext.member)
+
+UCONTEXT_FLAGS			ucontext (uc_flags)
+UCONTEXT_LINK			ucontext (uc_link)
+UCONTEXT_STACK			ucontext (uc_stack)
+UCONTEXT_MCONTEXT		ucontext (uc_mcontext)
+UCONTEXT_SIGMASK		ucontext (uc_sigmask)
+
+STACK_SP			stack (ss_sp)
+STACK_SIZE			stack (ss_size)
+STACK_FLAGS			stack (ss_flags)
+
+MCONTEXT_GREGS			mcontext (gregs)
+MCONTEXT_FPREGS			mcontext (fpregs)
+MCONTEXT_PC			mcontext (gregs)
+MCONTEXT_FSR			mcontext (fsr)
+
+UCONTEXT_SIZE			sizeof (ucontext_t)
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ustat.c b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ustat.c
new file mode 100644
index 0000000..a309f71
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ustat.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/ustat.h>
+#include <sys/sysmacros.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+int
+ustat (dev_t dev, struct ustat *ubuf)
+{
+  unsigned long k_dev;
+
+  /* We must convert the value to dev_t type used by the kernel.  */
+  k_dev = ((major (dev) & 0xff) << 8) | (minor (dev) & 0xff);
+
+  return INLINE_SYSCALL (ustat, 2, k_dev, CHECK_1 (ubuf));
+}
diff --git a/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/vfork.S b/glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/vfork.S
new file mode 100644
index 0000000..cc30fe5
--- /dev/null
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/vfork.S
@@ -0,0 +1,65 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* vfork() is just a special case of clone().  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#include <asm/unistd.h>
+#include <sgidefs.h>
+
+#ifndef SAVE_PID
+#define SAVE_PID
+#endif
+
+#ifndef RESTORE_PID
+#define RESTORE_PID
+#endif
+
+
+/* int vfork() */
+
+	.text
+LEAF(__vfork)
+
+	SAVE_PID
+
+	li		a0, 0x4111	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
+	move		a1, sp
+	li		a2, 0
+	li		a3, 0
+	li		a4, 0
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	scall
+
+	bltz		v0,L(error)
+
+	RESTORE_PID
+
+	ret
+
+	/* Something bad happened -- no child created.  */
+L(error):
+	j		__syscall_error
+
+	END(__vfork)
+
+libc_hidden_def(__vfork)
+weak_alias (__vfork, vfork)
